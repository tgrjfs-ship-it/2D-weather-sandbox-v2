<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>3D Weather Simulation</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { width: 100vw; height: 100vh; overflow: hidden; font-family: Arial, sans-serif; touch-action: none; }
    #container { width: 100%; height: 100%; }
    .ui-panel { position: absolute; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); background: rgba(0,0,0,0.45); padding: 15px; border-radius: 8px; z-index: 900; }
    #stats { top: 20px; left: 20px; max-width: 300px; pointer-events: auto; font-size: 13px; line-height: 1.8; }
    #controls { bottom: 20px; left: 20px; min-width: 280px; pointer-events: auto; }
    #info { top: 20px; right: 20px; max-width: 280px; font-size: 11px; line-height: 1.5; pointer-events: auto; }
    #radar { bottom: 20px; right: 20px; width: 200px; height: 200px; pointer-events: auto; }
    #radarCanvas { width: 100%; height: 100%; border-radius: 50%; border: 3px solid rgba(0,255,0,0.5); background: rgba(0,20,0,0.8); }
    #toggleGui { position: absolute; top: 12px; right: 18px; padding: 10px 16px; background: rgba(0,0,0,0.6); color: white; border: 2px solid rgba(255,255,255,0.3); border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: bold; z-index: 1001; transition: all 0.3s; }
    #toggleGui:hover { background: rgba(0,0,0,0.8); }
    #pauseBtn { position: absolute; top: 12px; left: 18px; padding: 10px 14px; background: rgba(0,0,0,0.6); color: white; border: 2px solid rgba(255,255,255,0.3); border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: bold; z-index: 1001; transition: all 0.2s; }
    #resetBtn { position: absolute; top: 12px; left: 108px; padding: 10px 12px; background: rgba(0,0,0,0.6); color: white; border: 2px solid rgba(255,255,255,0.3); border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: bold; z-index: 1001; transition: all 0.2s; }
    input[type="range"] { width: 100%; }
    .slider-group { margin-bottom: 15px; }
    .slider-label { display: block; font-size: 13px; margin-bottom: 5px; }
    .slider-hint { font-size: 11px; opacity: 0.7; margin-top: 3px; }
    .warning { color: #ff6666; font-weight: bold; }
    h2 { margin: 0 0 15px 0; font-size: 18px; }
    h3 { margin: 0 0 15px 0; font-size: 16px; }

    /* Vignette overlay */
    #vignette {
      position: absolute;
      left: 0; top: 0; right: 0; bottom: 0;
      pointer-events: none;
      z-index: 1002;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.0) 50%, rgba(0,0,0,0.45) 100%);
      mix-blend-mode: multiply;
      opacity: 0;
      transition: opacity 0.45s ease;
      }

    /* Responsive layout fixes to avoid overlapping UI on narrow screens */
    @media (max-width: 900px) {
      /* Slightly shrink panels and ensure spacing */
      #stats { left: 12px; top: 12px; max-width: 220px; font-size: 12px; padding: 12px; }
      #controls { left: 12px; right: 12px; bottom: 12px; min-width: auto; width: auto; padding: 12px; border-radius: 10px; }
      #info { display: none; } /* hide verbose info on smaller screens */
      #radar { right: 12px; bottom: 84px; width: 140px; height: 140px; }
      #toggleGui { top: 10px; right: 10px; padding: 8px 12px; font-size: 13px; }
      #pauseBtn, #resetBtn { top: 10px; left: 10px; padding: 8px 10px; font-size: 13px; }
      #resetBtn { left: 76px; }
    }

    /* Mobile: stack controls as a bottom sheet and keep stats compact */
    @media (max-width: 520px) {
      .ui-panel { padding: 10px; border-radius: 12px; }
      #stats { left: 8px; top: 8px; max-width: 160px; font-size: 12px; line-height: 1.4; z-index: 1000; }
      #controls {
        left: 6px;
        right: 6px;
        bottom: 6px;
        min-width: unset;
        width: auto;
        max-height: 46vh;
        overflow-y: auto;
        padding-bottom: 18px;
        z-index: 1000;
      }
      #radar {
        right: 8px;
        bottom: calc(6px + 46vh + 8px);
        width: 110px;
        height: 110px;
      }
      #toggleGui { top: 8px; right: 8px; z-index: 1002; }
      #pauseBtn { top: 8px; left: 8px; z-index: 1002; }
      #resetBtn { top: 8px; left: 70px; z-index: 1002; }
    }

    /* Prevent UI panels from covering the canvas interaction area when hidden */
    .ui-panel[style*="display: none"] { pointer-events: none; }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="vignette"></div>
  <button id="toggleGui">üëÅÔ∏è Show GUI</button>
  <button id="pauseBtn">‚è∏Ô∏è Pause</button>
  <button id="resetBtn">üîÑ Reset</button>
  
  <div id="stats" class="ui-panel" style="display: block;">
    <h2>Weather Simulation</h2>
    <div><strong>Total Clouds:</strong> <span id="cloudCount">0</span></div>
    <div id="cloudTypesList" style="margin-left: 10px; font-size: 11px; opacity: 0.9; line-height: 1.4; margin-top: 5px;"></div>
    <div style="margin-top: 8px;"><strong>Precipitation:</strong> <span id="precipitation">None</span></div>
    <div id="tornadoWarning" class="warning" style="display: none;">üå™Ô∏è Active Tornadoes: <span id="tornadoCount">0</span></div>
    <div><strong>Wind Speed:</strong> <span id="windSpeed">0</span> km/h</div>
    <div><strong>Temperature:</strong> <span id="tempDisplay">20</span>¬∞C</div>
    <div><strong>Humidity:</strong> <span id="humidityDisplay">50</span>%</div>
    <div><strong>FPS:</strong> <span id="fps">0</span></div>
  </div>
  
  <div id="controls" class="ui-panel" style="display: block;">
    <h3>Simulation Controls</h3>
    <div class="slider-group">
      <label class="slider-label">Temperature: <span id="tempValue">20</span>¬∞C</label>
      <input type="range" id="tempSlider" min="-30" max="100" step="1" value="20">
      <div class="slider-hint">Higher temp = more severe storms</div>
    </div>
    <div class="slider-group">
      <label class="slider-label">Humidity: <span id="humidityValue">50</span>%</label>
      <input type="range" id="humiditySlider" min="0" max="100" step="1" value="50">
      <div class="slider-hint">Controls moisture and cloud formation</div>
    </div>
    <div class="slider-group">
      <label class="slider-label">Formation Rate: <span id="formationValue">1.00</span>x</label>
      <input type="range" id="formationSlider" min="0.1" max="10" step="0.1" value="1.0">
      <div class="slider-hint">Higher = more clouds form</div>
    </div>
    <div class="slider-group">
      <label class="slider-label">Wind Speed: <span id="windValue">1.00</span>x</label>
      <input type="range" id="windSlider" min="0" max="3" step="0.1" value="1.0">
    </div>
    <div class="slider-group">
      <label class="slider-label">Simulation Speed: <span id="speedValue">1.00</span>x</label>
      <input type="range" id="speedSlider" min="0.1" max="10" step="0.1" value="1.0">
    </div>

    <!-- Cloud toggles: enable/disable individual cloud types -->
    <div class="slider-group" style="margin-top:8px;">
      <label class="slider-label">Cloud Types (toggle formation)</label>
      <div id="cloudTogglePanel" style="display:flex; flex-wrap:wrap; gap:6px;">
        <label style="font-size:12px;"><input type="checkbox" data-cloud="altostratus" checked> Altostratus</label>
        <label style="font-size:12px;"><input type="checkbox" data-cloud="cumulus_humilis" checked> Cumulus Humilis</label>
        <label style="font-size:12px;"><input type="checkbox" data-cloud="cumulus_congestus" checked> Cumulus Congestus</label>
        <label style="font-size:12px;"><input type="checkbox" data-cloud="cumulonimbus" checked> Cumulonimbus</label>
        <label style="font-size:12px;"><input type="checkbox" data-cloud="supercell" checked> Supercell</label>
        <label style="font-size:12px;"><input type="checkbox" data-cloud="derecho" checked> Derecho</label>
        <label style="font-size:12px;"><input type="checkbox" data-cloud="stratus" checked> Stratus</label>
        <label style="font-size:12px;"><input type="checkbox" data-cloud="nimbostratus" checked> Nimbostratus</label>
        <label style="font-size:12px;"><input type="checkbox" data-cloud="cirrus" checked> Cirrus</label>
        <label style="font-size:12px;"><input type="checkbox" data-cloud="pyrocumulus" checked> Pyrocumulus</label>
        <label style="font-size:12px;"><input type="checkbox" data-cloud="pyrocumulonimbus" checked> Pyrocumulonimbus</label>
      </div>
      <div class="slider-hint">Uncheck to prevent that cloud type from forming</div>
    </div>

    <!-- Volcano spawn toggle -->
    <div class="slider-group" style="margin-top:6px;">
      <label style="font-size:13px;"><input type="checkbox" id="spawnVolcanoToggle" checked> Spawn Volcanoes at Start</label>
      <div class="slider-hint">Toggle whether volcanoes are generated when the simulation starts or resets</div>
    </div>

    <!-- New toggles: Shadows & Hail -->
    <div class="slider-group" style="margin-top:8px;">
      <label style="font-size:13px;"><input type="checkbox" id="toggleShadows" checked> Enable Shadows</label>
      <div class="slider-hint">Toggle renderer shadows on/off (may affect performance)</div>
    </div>
    <div class="slider-group" style="margin-top:6px;">
      <label style="font-size:13px;"><input type="checkbox" id="toggleHail" checked> Allow Hail</label>
      <div class="slider-hint">Toggle hail generation in precipitation (for performance)</div>
    </div>
  </div>
  
  <div id="info" class="ui-panel" style="display: block;">
    <div style="margin-bottom: 10px; font-weight: bold; font-size: 12px;">üéÆ Controls (Surface View)</div>
    <div><strong>WASD / Arrows:</strong> Move around</div>
    <div><strong>Q / E:</strong> Crouch / Stand (0.5-5m)</div>
    <div><strong>Mouse Drag:</strong> Look around</div>
    <div><strong>Mobile:</strong> Left=Move, Right=Look</div>
    <div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.3); font-weight: bold; font-size: 12px;">üì° Radar Legend</div>
    <div style="margin-top: 6px; opacity: 0.9;">
      ‚Ä¢ <span style="color: #00ff00;">Green</span>: Light rain<br/>
      ‚Ä¢ <span style="color: #ffff00;">Yellow</span>: Moderate rain<br/>
      ‚Ä¢ <span style="color: #ff6600;">Orange</span>: Cumulonimbus<br/>
      ‚Ä¢ <span style="color: #ff0000;">Red</span>: Severe (Supercell/Derecho)<br/>
      ‚Ä¢ <span style="color: #ff00ff;">Purple</span>: Tornado üå™Ô∏è
    </div>
    <div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.3); font-weight: bold; font-size: 12px;">‚ö†Ô∏è Severe Weather</div>
    <div style="margin-top: 6px; opacity: 0.9;">
      High temp (>25¬∞C) + High humidity (>80%) = Supercells & Tornadoes
    </div>
  </div>
  
  <div id="radar" class="ui-panel" style="display: block;">
    <canvas id="radarCanvas" width="200" height="200"></canvas>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const state = {
      controls: { evaporationRate: 1.0, simulationSpeed: 1.0, windSpeed: 1.0, humidity: 50, temperature: 20, spawnVolcanoes: true, enableShadows: true, allowHail: true },
      guiVisible: true,
      paused: false
    };
    
    document.getElementById('toggleGui').addEventListener('click', () => {
      state.guiVisible = !state.guiVisible;
      const display = state.guiVisible ? 'block' : 'none';
      ['stats', 'controls', 'info', 'radar'].forEach(id => document.getElementById(id).style.display = display);
      // show "Hide GUI" when panels are visible and "Show GUI" when hidden
      document.getElementById('toggleGui').textContent = state.guiVisible ? 'üôà Hide GUI' : 'üëÅÔ∏è Show GUI';
    });

    document.getElementById('pauseBtn').addEventListener('click', () => {
      state.paused = !state.paused;
      document.getElementById('pauseBtn').textContent = state.paused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
    });
    
    document.getElementById('resetBtn').addEventListener('click', () => {
      resetSimulation();
    });
    
    // resetSimulation: clear and reinitialize major subsystems and UI state
    function resetSimulation() {
      // pause briefly to avoid race during UI click
      state.paused = false;
      // reset control values to defaults
      state.controls = { evaporationRate: 1.0, simulationSpeed: 1.0, windSpeed: 1.0, humidity: 50, temperature: 20, spawnVolcanoes: state.controls.spawnVolcanoes, enableShadows: state.controls.enableShadows, allowHail: state.controls.allowHail };
      // update sliders and UI displays
      // use safe DOM queries (avoid relying on possibly-undefined global variables)
      const tempSliderEl = document.getElementById('tempSlider');
      const humiditySliderEl = document.getElementById('humiditySlider');
      const formationSliderEl = document.getElementById('formationSlider');
      const windSliderEl = document.getElementById('windSlider');
      const speedSliderEl = document.getElementById('speedSlider');
      if (tempSliderEl) tempSliderEl.value = state.controls.temperature;
      if (humiditySliderEl) humiditySliderEl.value = state.controls.humidity;
      if (formationSliderEl) formationSliderEl.value = state.controls.evaporationRate;
      if (windSliderEl) windSliderEl.value = state.controls.windSpeed;
      if (speedSliderEl) speedSliderEl.value = state.controls.simulationSpeed;
      document.getElementById('tempValue').textContent = state.controls.temperature;
      document.getElementById('humidityValue').textContent = state.controls.humidity;
      document.getElementById('formationValue').textContent = state.controls.evaporationRate.toFixed(2);
      document.getElementById('windValue').textContent = state.controls.windSpeed.toFixed(2);
      document.getElementById('speedValue').textContent = state.controls.simulationSpeed.toFixed(2);
      // update new toggles
      const shEl = document.getElementById('toggleShadows');
      const hailEl = document.getElementById('toggleHail');
      if (shEl) { shEl.checked = !!state.controls.enableShadows; renderer.shadowMap.enabled = !!state.controls.enableShadows; }
      if (hailEl) { hailEl.checked = !!state.controls.allowHail; }

      // clear clouds
      if (cloudSystem && cloudSystem.clouds) {
        cloudSystem.clouds.forEach(c => {
          c.userData.structureElements.forEach(e => {
            if (e.geometry) e.geometry.dispose();
            if (e.material) e.material.dispose();
          });
          if (c.userData.anvilLight) {
            scene.remove(c.userData.anvilLight);
            if (c.userData.anvilLight.dispose) c.userData.anvilLight.dispose();
          }
          scene.remove(c);
        });
        cloudSystem.clouds.length = 0;
      }

      // reset precipitation system
      if (precipitationSystem) precipitationSystem.reset();

      // reset tree system
      if (treeSystem) treeSystem.reset();

      // reset tornadoes if present
      if (typeof tornadoSystem !== 'undefined' && tornadoSystem && tornadoSystem.activeTornadoes) {
        tornadoSystem.activeTornadoes.forEach(t => {
          t.traverse(node => {
            if (node.geometry) node.geometry.dispose();
            if (node.material) node.material.dispose();
          });
          if (t.parent) t.parent.remove(t);
        });
        tornadoSystem.activeTornadoes.length = 0;
      }

      // reset volcano visuals and position
      if (typeof volcanoes !== 'undefined' && volcanoes && volcanoes.length) {
        volcanoes.forEach(v => {
          if (!v) return;
          v.active = true;
          if (v.ember && v.ember.material) v.ember.material.opacity = 0.0;
          if (v.mesh && v.position) v.mesh.position.set(v.position.x, 3, v.position.z);
        });
      }

      // respawn volcanoes per user toggle: clear array first if user disabled spawning
      if (typeof volcanoes !== 'undefined') {
        if (!state.controls.spawnVolcanoes) {
          // deactivate existing volcanoes
          volcanoes.forEach(v => {
            if (!v) return;
            v.active = false;
            if (v.ember && v.ember.material) v.ember.material.opacity = 0.0;
            if (v.mesh) scene.remove(v.mesh);
            if (v.ember) scene.remove(v.ember);
          });
          volcanoes.length = 0;
        } else {
          // if none exist, spawn fresh set
          if (volcanoes.length === 0) spawnVolcanoes();
        }
      }

      // reset camera position and orientation
      camera.position.set(0, 1.7, 0);
      camera.lookAt(0, 1.7, 10);
      if (cameraController) {
        cameraController.yaw = 0;
        cameraController.pitch = 0;
        cameraController.shake.set(0,0,0);
        cameraController.shakeVel.set(0,0,0);
      }

      // reset UI counts
      document.getElementById('cloudCount').textContent = 0;
      document.getElementById('cloudTypesList').innerHTML = '';
      document.getElementById('precipitation').textContent = 'None';
      document.getElementById('tornadoCount').textContent = 0;
      document.getElementById('tornadoWarning').style.display = 'none';
      document.getElementById('windSpeed').textContent = (windSystem ? (windSystem.getWindSpeed() * state.controls.windSpeed * 100).toFixed(1) : '0.0');
      document.getElementById('tempDisplay').textContent = state.controls.temperature.toFixed(1);
      document.getElementById('humidityDisplay').textContent = state.controls.humidity.toFixed(1);
    }
    
    ['temp', 'humidity', 'formation', 'wind', 'speed'].forEach(name => {
      document.getElementById(name + 'Slider').addEventListener('input', (e) => {
        const val = parseFloat(e.target.value);
        document.getElementById(name + 'Value').textContent = name === 'temp' ? val : val.toFixed(2);
        if (name === 'temp') state.controls.temperature = val;
        else if (name === 'humidity') state.controls.humidity = val;
        else if (name === 'formation') state.controls.evaporationRate = val;
        else if (name === 'wind') state.controls.windSpeed = val;
        else if (name === 'speed') state.controls.simulationSpeed = val;
      });
    });

    // remove fog and shadows: no scene.fog, disable shadow casting/receiving
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
    camera.position.set(0, 1.7, 0);
    camera.lookAt(0, 1.7, 10);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    // shadow map initially controlled by UI toggle (may remain off for performance)
    renderer.shadowMap.enabled = !!state.controls.enableShadows;
    document.getElementById('container').appendChild(renderer.domElement);

    // simple angle difference helper to replace THREE.MathUtils.angleDifference (not available in this Three.js version)
    function angleDifference(a, b) {
      let d = (a - b) % (Math.PI * 2);
      if (d < -Math.PI) d += Math.PI * 2;
      else if (d > Math.PI) d -= Math.PI * 2;
      return d;
    }

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const sunLight = new THREE.DirectionalLight(0xfff4e6, 1.2);
    sunLight.position.set(50, 80, 30);
    // do not cast shadows
    scene.add(sunLight);
    const backLight = new THREE.DirectionalLight(0x6ba3ff, 0.4);
    backLight.position.set(-50, 30, -50);
    scene.add(backLight);

    // shared rain column material (semi-transparent vertical column)
    const rainColumnMaterial = new THREE.MeshBasicMaterial({
      color: 0x3aa0ff,
      transparent: true,
      opacity: 0.18,
      depthWrite: false,
      side: THREE.DoubleSide
    });

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(500, 500),
      new THREE.MeshStandardMaterial({ color: 0x5a8a3a, roughness: 0.9 })
    );
    ground.rotation.x = -Math.PI / 2;
    // do not receive shadows
    scene.add(ground);

    function createCloudMaterial() {
      return new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          density: { value: 0.95 }, // increased base density for better visibility
          lightColor: { value: new THREE.Color(0xffffff) },
          shadowColor: { value: new THREE.Color(0x557799) },
          moisture: { value: 0.9 }, // higher default moisture to highlight structure
          sunPosition: { value: new THREE.Vector3(1, 1, 0.5) }
        },
        vertexShader: `
          varying vec3 vPosition;
          varying vec3 vNormal;
          varying vec2 vUv;
          varying vec3 vWorldPosition;
          void main() {
            vPosition = position;
            vNormal = normalize(normalMatrix * normal);
            vUv = uv;
            vec4 worldPos = modelMatrix * vec4(position, 1.0);
            vWorldPosition = worldPos.xyz;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          uniform float density;
          uniform vec3 lightColor;
          uniform vec3 shadowColor;
          uniform float moisture;
          uniform vec3 sunPosition;
          varying vec3 vPosition;
          varying vec3 vNormal;
          varying vec2 vUv;
          varying vec3 vWorldPosition;
          
          float hash(vec3 p) {
            p = fract(p * vec3(0.1031, 0.1030, 0.0973));
            p += dot(p, p.yxz + 33.33);
            return fract((p.x + p.y) * p.z);
          }
          
          float noise(vec3 x) {
            vec3 p = floor(x);
            vec3 f = fract(x);
            f = f * f * (3.0 - 2.0 * f);
            return mix(
              mix(mix(hash(p + vec3(0,0,0)), hash(p + vec3(1,0,0)), f.x),
                  mix(hash(p + vec3(0,1,0)), hash(p + vec3(1,1,0)), f.x), f.y),
              mix(mix(hash(p + vec3(0,0,1)), hash(p + vec3(1,0,1)), f.x),
                  mix(hash(p + vec3(0,1,1)), hash(p + vec3(1,1,1)), f.x), f.y),
              f.z
            );
          }
          
          float fbm(vec3 p) {
            float f = 0.0;
            float scale = 1.0;
            float weight = 0.5;
            for(int i = 0; i < 6; i++) {
              f += weight * noise(p * scale);
              scale *= 2.07;
              weight *= 0.5;
            }
            return f;
          }
          
          void main() {
            vec3 pos = vWorldPosition * 0.08;
            pos.x += time * 0.02;
            pos.y += time * 0.01;
            float n = fbm(pos * 0.8) * 0.7 + fbm(pos * 2.0) * 0.35;
            n = smoothstep(0.28, 0.88, n);
            float edgeFade = 1.0 - smoothstep(0.18, 1.2, length(vUv - 0.5) * 2.0);
            n *= edgeFade;
            vec3 lightDir = normalize(sunPosition);
            
            // --- Enhanced Shading Model ---
            float NdotL = dot(vNormal, lightDir);
            
            // 1. Core diffuse lighting (standard)
            float diffuse = max(0.0, NdotL);
            
            // 2. Ambient occlusion / Shadowed side (using vNormal against opposing light)
            float backScatter = max(0.0, -NdotL) * 0.5;
            
            // 3. Simple phase function approximation (forward scatter for bright edges)
            vec3 viewDir = normalize(cameraPosition - vWorldPosition);
            float LdotV = dot(lightDir, viewDir);
            float phase = (1.0 + LdotV * 0.5);
            
            // Total light amount
            float lightAmount = diffuse * 1.0 + backScatter * 0.4 + 0.3; // Base ambient
            lightAmount *= phase; // Apply phase boost

            // Darken color based on moisture (for heavy rain/ice clouds)
            vec3 baseCloudColor = mix(vec3(0.9, 0.92, 0.95), vec3(0.7, 0.75, 0.85), moisture * 0.4);
            vec3 shadowedCloudColor = mix(shadowColor, vec3(0.12, 0.12, 0.18), moisture * 0.8);
            
            // Combine colors based on light amount
            vec3 color = mix(shadowedCloudColor, baseCloudColor, lightAmount);
            
            // Final density calculation
            float finalDensity = n * density * (0.5 + moisture * 0.5);
            
            // Boost alpha near top-facing normals for better visibility and ensure always visible
            float normalMask = smoothstep(0.0, 0.6, NdotL);
            finalDensity = clamp(finalDensity + normalMask * 0.35, 0.0, 1.0);
            
            // extra boost for visibility of thin structures
            finalDensity = min(1.0, finalDensity * 1.25);
            
            gl_FragColor = vec4(color, finalDensity);
          }
        `,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false,
        blending: THREE.NormalBlending
      });
    }

    // new: simple halo texture generator (canvas) - used for cirrus halo sprites
    function createHaloTexture(size = 256, color = 'rgba(255,240,220,1.0)') {
      const cvs = document.createElement('canvas');
      cvs.width = cvs.height = size;
      const ctx = cvs.getContext('2d');
      const grad = ctx.createRadialGradient(size/2, size/2, size*0.05, size/2, size/2, size/2);
      grad.addColorStop(0, color.replace('1.0','0.95'));
      grad.addColorStop(0.35, color.replace('1.0','0.4'));
      grad.addColorStop(1, 'rgba(255,255,255,0.0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,size,size);
      const tex = new THREE.CanvasTexture(cvs);
      tex.needsUpdate = true;
      return tex;
    }

    // new: rainshaft shader material factory for realistic vertical shafts
    function createRainShaftMaterial() {
      return new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uIntensity: { value: 1.0 },
          uColor: { value: new THREE.Color(0x4aa0ff) },
          uWind: { value: new THREE.Vector2(0,0) },
          uVirga: { value: 0.0 }
        },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vPos;
          void main(){
            // preserve uv for cylinder/cone mapping
            vUv = uv;
            vPos = position;
            vec4 mv = modelViewMatrix * vec4(position,1.0);
            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          uniform float uTime;
          uniform float uIntensity;
          uniform vec3 uColor;
          uniform vec2 uWind;
          uniform float uVirga;
          varying vec2 vUv;
          varying vec3 vPos;

          // radial taper function (0 at edge -> 1 at center)
          float radialFalloff(vec2 uv) {
            float x = (uv.x - 0.5);
            // Stronger core and soft edges, narrower profile
            return pow(max(0.0, 1.0 - abs(x)*2.5), 1.8);
          }

          // simple pseudo-noise for streak / edge variation
          float hash(float n){ return fract(sin(n)*43758.5453); }
          float noise(vec2 p){
            vec2 i = floor(p);
            vec2 f = fract(p);
            f = f*f*(3.0-2.0*f);
            float a = hash(i.x + i.y*57.0);
            float b = hash(i.x+1.0 + i.y*57.0);
            float c = hash(i.x + (i.y+1.0)*57.0);
            float d = hash(i.x+1.0 + (i.y+1.0)*57.0);
            return mix(mix(a,b,f.x), mix(c,d,f.x), f.y);
          }

          void main(){
            float y = vUv.y;
            // vertical animated noise for streaking, scaled by wind
            vec2 coord = vec2(
              vUv.x*8.0, // Increased horizontal stretch for turbulence
              vUv.y*12.0 - uTime*8.0 // Faster vertical movement
            );
            
            // Add wind shear/movement to texture coordinates
            coord.x += uWind.x * y * 0.4;
            coord.y += uWind.y * y * 0.2;

            float n = noise(coord) * 0.6 + noise(coord*2.8)*0.3; // Higher freq noise for streaks

            // core density calculation
            float core = radialFalloff(vUv);
            
            // Create sharp vertical streaks based on noise and core density
            float streakIntensity = 0.5 + n * 0.5;
            float streak = smoothstep(0.0, 0.5, streakIntensity) * core;

            float fadeTop = smoothstep(0.05, 0.25, y); // Start rain slightly below top
            float fadeBottom = 1.0 - smoothstep(0.9, 1.0, y);

            // Ragged edges using noise for turbulence
            float edgeNoise = noise(vec2(vUv.x*16.0, vUv.y*8.0 + uTime*1.2));
            float edgeMask = smoothstep(0.1, 0.7, core + edgeNoise - 0.2);

            // Base alpha calculation
            float alpha = (0.05 + n * 0.6) * streak * fadeTop * fadeBottom * uIntensity * edgeMask;

            // Virga: fade lower part when rain evaporates before ground
            // Use smoothstep for a softer transition
            float virgaMask = mix(1.0, smoothstep(0.0, 0.75, y), uVirga);
            alpha *= virgaMask;

            // Color modulation: darker blue/gray for higher intensity/shadow
            vec3 darkCol = mix(vec3(0.18, 0.25, 0.35), uColor, 0.4);
            vec3 col = mix(darkCol, vec3(1.0), alpha * 0.8 + 0.1); // Brighten core
            
            gl_FragColor = vec4(col, alpha);
            if (gl_FragColor.a < 0.005) discard;
          }
        `,
        transparent: true,
        depthWrite: false,
        blending: THREE.NormalBlending,
        side: THREE.DoubleSide
      });
    }

    class WindSystem {
      constructor() {
        this.baseSpeed = 0.03;
        this.direction = new THREE.Vector2(1, 0);
        this.turbulence = 0;
        this.gustTimer = 0;
        this.gustDuration = 0;
      }
      update(deltaTime) {
        const dirChange = Math.sin(Date.now() * 0.0001) * 0.01;
        this.direction.set(Math.cos(dirChange), Math.sin(dirChange)).normalize();
        this.gustTimer -= deltaTime;
        if (this.gustTimer <= 0) {
          this.gustTimer = 5 + Math.random() * 10;
          this.gustDuration = 2 + Math.random() * 3;
          this.turbulence = Math.random() * 0.5;
        }
        if (this.gustDuration > 0) {
          this.gustDuration -= deltaTime;
          this.turbulence *= 0.95;
        }
      }
      getWindAtAltitude(altitude) {
        const speed = this.baseSpeed * (1 + (altitude / 30) * 0.3) * (1 + this.turbulence);
        return { x: this.direction.x * speed, y: this.direction.y * speed, turbulence: this.turbulence };
      }
      getWindSpeed() {
        return this.baseSpeed * (1 + this.turbulence);
      }
    }

    class Tree {
      constructor(x, z, scale = 1.0) {
        this.group = new THREE.Group();
        // trunk
        const trunkGeo = new THREE.CylinderGeometry(0.12 * scale, 0.18 * scale, 1.2 * scale, 8);
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x6b3b1b, roughness: 1.0 });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = 0.6 * scale;
        this.group.add(trunk);
        // foliage simple layered spheres
        const foliageMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32, roughness: 0.9, metalness: 0.0 });
        const f1 = new THREE.Mesh(new THREE.SphereGeometry(0.9 * scale, 10, 10), foliageMat);
        const f2 = new THREE.Mesh(new THREE.SphereGeometry(0.7 * scale, 10, 10), foliageMat);
        f1.position.y = 1.25 * scale; f2.position.y = 1.6 * scale;
        this.group.add(f1); this.group.add(f2);
        this.group.position.set(x, 0, z);
        this.health = 1.0; // 1.0 = healthy, 0 = destroyed
        this.sway = 0; // current sway angle for visual
        this.swayVel = 0;
        scene.add(this.group);
        this._parts = { trunk, f1, f2 };
      }
      applyGust(forceVec, strength) {
        // apply impulse to sway velocity using both lateral components (x and z)
        const lx = (forceVec.x || 0);
        const lz = (forceVec.z || forceVec.y || 0);
        const lateral = lx + lz;
        // increase impulse sensitivity so trees visibly react to gusts
        const impulse = Math.min(3.5, 0.18 + strength * 3.6);
        this.swayVel += (lateral * impulse) * 1.6;
        // damage scales a bit stronger for very powerful gusts
        const damage = Math.min(0.45, strength * 0.18);
        this.health -= damage;
        this.health = Math.max(0, this.health);
        if (this.health <= 0.02) {
          // collapse: quick scale-down and remove geometry visually
          this.group.scale.y = Math.max(0.02, this.group.scale.y * 0.4);
          // tint to brown/dry
          this._parts.f1.material.color.setHex(0x6e4d2a);
          this._parts.f2.material.color.setHex(0x6e4d2a);
        }
      }
      update(deltaTime) {
        // simple damped oscillation for sway
        this.swayVel *= 0.92;
        this.sway += this.swayVel * deltaTime * 30;
        // clamp sway for realism
        this.sway = Math.max(-0.9, Math.min(0.9, this.sway));
        // apply to foliage as small rotation
        this.group.rotation.z = Math.sin(this.sway) * 0.08;
        // if health very low slowly drop leaves and shrink
        if (this.health < 0.2) {
          const t = Math.max(0.05, this.health);
          this.group.scale.set(t, t, t);
        }
      }
      dispose() {
        // cleanup
        scene.remove(this.group);
        [this._parts.trunk.geometry, this._parts.f1.geometry, this._parts.f2.geometry].forEach(g => g.dispose());
        [this._parts.trunk.material, this._parts.f1.material, this._parts.f2.material].forEach(m => m.dispose());
      }
    }

    class TreeSystem {
      constructor() {
        this.trees = [];
        this.gridRadius = 80;
        this.populate(120);
      }
      populate(count) {
        // randomly scatter trees across a portion of the ground
        for (let i = 0; i < count; i++) {
          const x = (Math.random() - 0.5) * this.gridRadius * 1.2;
          const z = (Math.random() - 0.5) * this.gridRadius * 1.2;
          const s = 0.6 + Math.random() * 1.2;
          const t = new Tree(x, z, s);
          this.trees.push(t);
        }
      }
      applyGustAt(position, radius, directionVec, power) {
        // find trees within radius and apply gust scaled by proximity and cloud power
        this.trees.forEach(t => {
          const dist = Math.hypot(t.group.position.x - position.x, t.group.position.z - position.z);
          if (dist <= radius) {
            const proximity = 1 - (dist / radius);
            const strength = Math.min(1, power * proximity);
            // pass a simple directional vector with x and z components for lateral push
            const forceVec = { x: directionVec.x, z: directionVec.z || directionVec.y || 0 };
            t.applyGust(forceVec, strength);
          }
        });
      }
      update(deltaTime) {
        for (let i = this.trees.length - 1; i >= 0; i--) {
          const t = this.trees[i];
          t.update(deltaTime);
          // fully destroyed trees get removed after being nearly invisible
          if (t.health <= 0 && t.group.scale.y < 0.06) {
            t.dispose();
            this.trees.splice(i, 1);
          }
        }
      }
      reset() {
        this.trees.forEach(t => t.dispose());
        this.trees.length = 0;
        this.populate(120);
      }
    }

    class CloudSystem {
      constructor() {
        this.clouds = [];
        this.temperature = 20;
        this.humidity = 50;
        this.evaporationRate = 1.0;
        // allow toggling of cloud types from UI
        this.allowedTypes = {
          altostratus: true, cumulus_humilis: true, cumulus_congestus: true,
          cumulonimbus: true, supercell: true, derecho: true, stratus: true,
          nimbostratus: true, cirrus: true, pyrocumulus: true, pyrocumulonimbus: true
        };
      }
      determineCloudType() {
        const r = Math.random(), h = this.humidity, t = this.temperature;
        // check any active volcano within range to bias pyro-cloud formation
        if (typeof volcanoes !== 'undefined' && volcanoes && volcanoes.length > 0) {
          // bias pyro selection by volcano size and proximity; large volcanoes strongly favor pyro-clouds
          for (let vi = 0; vi < volcanoes.length; vi++) {
            const v = volcanoes[vi];
            if (!v || !v.active) continue;
            const dx = (camera.position.x - v.position.x);
            const dz = (camera.position.z - v.position.z);
            const dist = Math.sqrt(dx*dx + dz*dz);
            if (dist > v.influenceRadius) continue;
            // probability scales with volcano.size and proximity (closer & bigger => much higher)
            const sizeFactor = THREE.MathUtils.clamp(v.size / 1.0, 0.6, 3.0);
            const prox = 1 - (dist / Math.max(1, v.influenceRadius));
            const pyroChance = THREE.MathUtils.clamp(0.12 + sizeFactor * 0.24 + prox * 0.6, 0, 0.98);
            if (Math.random() < pyroChance) {
              // prefer pyrocumulonimbus on very large/active volcanoes with enough moisture/temperature
              if (h > 68 && t > 16 && v.size > 1.6 && Math.random() < 0.6 && this.allowedTypes.pyrocumulonimbus) return 'pyrocumulonimbus';
              // otherwise create pyrocumulus (frequent on even modest volcanoes)
              if (this.allowedTypes.pyrocumulus) return 'pyrocumulus';
            }
          }
        }
        // explicit, stricter condition checks per cloud type (deterministic thresholds + small randomness)
        if (this.allowedTypes.derecho && h >= 88 && t >= 26 && r > 0.985) return 'derecho';
        if (this.allowedTypes.supercell && h >= 82 && t >= 24 && r > 0.94) return 'supercell';
        if (this.allowedTypes.cumulonimbus && h >= 74 && t >= 20 && r > 0.86) return 'cumulonimbus';
        if (this.allowedTypes.cumulus_congestus && h >= 68 && t >= 14 && r > 0.78) return 'cumulus_congestus';
        if (this.allowedTypes.nimbostratus && h >= 78 && t >= 6 && r > 0.7) return 'nimbostratus';
        if (this.allowedTypes.stratus && h >= 60 && t <= 24 && r > 0.58) return 'stratus';
        if (this.allowedTypes.cirrus && t <= 10 && r > 0.5) return 'cirrus';
        // fair-weather cumulus (lower threshold but still tied to humidity)
        if (this.allowedTypes.cumulus_humilis && h >= 40 && r > 0.45) return 'cumulus_humilis';
        // fallback: altostratus when nothing stricter fits (mid-level sheet)
        if (this.allowedTypes.altostratus && h >= 35) return 'altostratus';
        // if altostratus is disabled, pick first available allowed type to ensure something spawns
        for (const k in this.allowedTypes) {
          // prevent pyro cloud types from being chosen by fallback - they must come only from active volcano logic above
          if ((k === 'pyrocumulus' || k === 'pyrocumulonimbus')) continue;
          if (this.allowedTypes[k]) return k;
        }
        // as last resort
        return 'altostratus';
      }
      createCloud() {
        const type = this.determineCloudType();
        const group = new THREE.Group();
        // bring forming clouds much closer to the camera: lower base altitudes and spawn near camera
        // reduce minimum altitude by 10m so forming clouds can appear much closer to ground (1-8m)
        // low-altitude default for forming clouds
        let alt = Math.max(1, (10 + Math.random() * 8) - 5); // effectively ~5..13m
        // make cumulus_congestus appear ~50% farther from surface
        if (type === 'cumulus_congestus') alt = alt * 1.75;
        if (type === 'cirrus') alt = 110 + Math.random() * 25;
        else if (type === 'altostratus') alt = 40 + Math.random() * 12;
        else if (type === 'cumulonimbus') alt = 28 + Math.random() * 18;
        else if (type === 'pyrocumulus') alt = 6 + Math.random() * 8; // relatively low but above ground smoke
        else if (type === 'pyrocumulonimbus') alt = 30 + Math.random() * 22; // deeper convection
        // bring clouds 25% closer to surface (reduce altitude) except very high cirrus
        if (type !== 'cirrus') {
          alt = Math.max(0.6, alt * 0.75);
        }
        // If this is a pyro-type, and there is a nearby active volcano, place the cloud above the volcano's summit (on top)
        let assignedVolcano = null;
        if ((type === 'pyrocumulus' || type === 'pyrocumulonimbus') && typeof volcanoes !== 'undefined' && volcanoes && volcanoes.length > 0) {
          let nearestVolcano = null;
          let nearestDist = Infinity;
          for (let vi = 0; vi < volcanoes.length; vi++) {
            const v = volcanoes[vi];
            if (!v || !v.active) continue;
            const dx = v.position.x - (camera.position.x || 0);
            const dz = v.position.z - (camera.position.z || 0);
            const dist = Math.sqrt(dx*dx + dz*dz);
            if (dist < nearestDist) { nearestDist = dist; nearestVolcano = v; }
          }
          // only commit to pyro placement if the nearest volcano is within an expanded reasonable range
          if (nearestVolcano && nearestDist <= nearestVolcano.influenceRadius + 80) {
            assignedVolcano = nearestVolcano;
            // position group horizontally above the volcano summit with small jitter and set altitude to just above summit
            group.position.set(
              nearestVolcano.mesh.position.x + (Math.random() - 0.5) * 6,
              Math.max(1.0, nearestVolcano.mesh.position.y + 4.5 * nearestVolcano.size + (type === 'pyrocumulonimbus' ? 6 + Math.random() * 6 : Math.random() * 3)),
              nearestVolcano.mesh.position.z + (Math.random() - 0.5) * 6
            );
          }
        }
        
        // reduced spawn radius and biased towards current camera position so new clouds appear near viewer
        const SPAWN_RADIUS = 240;
        const cx = (typeof camera !== 'undefined') ? camera.position.x : 0;
        const cz = (typeof camera !== 'undefined') ? camera.position.z : 0;
        // bias spawn to be closer to camera (within ~SPAWN_RADIUS/3) to ensure forming clouds are visible nearby
        if (!assignedVolcano) {
          // enforce a minimum spawn altitude to avoid clouds sitting at surface level
          const minSafeAlt = 3.0;
          const spawnAlt = Math.max(minSafeAlt, alt);
          group.position.set(cx + (Math.random() - 0.5) * (SPAWN_RADIUS / 2.5), spawnAlt, cz + (Math.random() - 0.5) * (SPAWN_RADIUS / 2.5));
        }
        
        // If the chosen type is a pyro-type but there's no nearby active volcano, force fallback to altostratus
        if ((type === 'pyrocumulus' || type === 'pyrocumulonimbus')) {
          // find nearest active volcano within required proximity
          let nearestVolcano = null;
          let nearestDist = Infinity;
          if (typeof volcanoes !== 'undefined' && volcanoes && volcanoes.length > 0) {
            for (let vi = 0; vi < volcanoes.length; vi++) {
              const v = volcanoes[vi];
              if (!v || !v.active) continue;
              const dx = v.position.x - group.position.x;
              const dz = v.position.z - group.position.z;
              const dist = Math.sqrt(dx*dx + dz*dz);
              if (dist < nearestDist) { nearestDist = dist; nearestVolcano = v; }
            }
          }
          // only keep pyro type when a volcano is actually nearby (within 360m); otherwise fallback
          if (!nearestVolcano || nearestDist > 360) {
            // fallback to non-pyro: prefer cumulonimbus if conditions allow, else altostratus
            if (this.allowedTypes.cumulonimbus && this.humidity >= 74 && this.temperature >= 20) {
              group.userData = group.userData || {};
              group.userData.forcedFallback = 'cumulonimbus';
            } else {
              group.userData = group.userData || {};
              group.userData.forcedFallback = 'altostratus';
            }
          } else {
            // place pyro cloud near the volcano (within small jitter)
            // prefer to position pyrocumulus/pyrocumulonimbus above the summit area, slightly higher than the cone
            group.position.set(
              nearestVolcano.mesh.position.x + (Math.random() - 0.5) * 6,
              Math.max(1.0, nearestVolcano.mesh.position.y + 4.5 * nearestVolcano.size + (type === 'pyrocumulonimbus' ? 6 + Math.random() * 6 : Math.random() * 3)),
              nearestVolcano.mesh.position.z + (Math.random() - 0.5) * 6
            );
          }
        }

        // if forcedFallback was set above, override the initial type variable for safe construction
        let effectiveType = type;
        if (group.userData && group.userData.forcedFallback) effectiveType = group.userData.forcedFallback;
        
        let canPrecip = false, alwaysPrecip = false, canTornado = false, thresh = 0.8;
        if (effectiveType === 'derecho' || effectiveType === 'supercell' || effectiveType === 'cumulonimbus' || effectiveType === 'cumulus_congestus' || effectiveType === 'altostratus' || effectiveType === 'nimbostratus') {
          canPrecip = true;
          if (effectiveType !== 'cumulus_congestus' && effectiveType !== 'altostratus') alwaysPrecip = true;
          thresh = 0.3;
        }
        if (effectiveType === 'supercell') canTornado = true;
        if (effectiveType === 'cumulonimbus' && this.temperature > 20) canTornado = Math.random() > 0.7;
        
        group.userData = Object.assign(group.userData || {}, {
          type: effectiveType, age: 0, maxAge: 900 + Math.random() * 600, moisture: 0.45, stage: 'forming',
          precipitating: false, canPrecipitate: canPrecip, alwaysPrecipitate: alwaysPrecip,
          precipitationThreshold: thresh, precipitationIntensity: 0, condensationLevel: 0,
          structureElements: [], initialY: Math.max(3, group.position.y), targetHeight: group.position.y,
          verticalGrowth: 0, horizontalExpansion: 1, baseScale: 1 + Math.random() * 0.8,
          canSpawnTornado: canTornado, hasTornado: false,
          // wind emission params for strong clouds
          lastGustTime: 0,
          gustCooldown: 6 + Math.random()*8
        });
        
        group.scale.set(0.01, 0.01, 0.01);
        // build with effectiveType (use effectiveType so pyro-specific visuals get handled correctly)
        this.buildInitialStructure(group, group.userData.type);
        scene.add(group);
        this.clouds.push(group);
      }
      buildInitialStructure(group, type) {
        // Treat pyro types as their corresponding cumulus structures but mark as pyro
        let baseType = type;
        if (type === 'pyrocumulus') baseType = 'cumulus_congestus';
        if (type === 'pyrocumulonimbus') baseType = 'cumulonimbus';
        if (group.userData && (type === 'pyrocumulus' || type === 'pyrocumulonimbus')) group.userData.pyro = true;

        const makePuff = (size, pos, dens = 0.95, moisture = 0.9) => {
          const puff = new THREE.Mesh(new THREE.SphereGeometry(size, 16, 16), createCloudMaterial());
          puff.material.uniforms.density.value = 0.0;
          puff.userData = puff.userData || {};
          // Boost pyro puffs target density to make them visually thicker/heavier and lower/darker shadow color
          let targetDens = dens;
          let shadowCol = 0x557799;
          if (group.userData && group.userData.pyro) {
            targetDens = Math.min(1.0, dens + 0.2 + Math.random() * 0.1);
            shadowCol = 0x5c4d40; // Ash/smoke color
            moisture = Math.min(1.0, moisture + 0.1);
          }

          puff.userData.targetDensity = targetDens;
          puff.material.uniforms.moisture.value = moisture;
          puff.material.uniforms.shadowColor.value = new THREE.Color(shadowCol);
          puff.position.copy(pos);
          group.add(puff);
          group.userData.structureElements.push(puff);
        };
        
        // --- Layered Cloud Structures (Stratus, Altostratus, Nimbostratus) ---
        if (baseType === 'stratus' || baseType === 'altostratus' || baseType === 'nimbostratus') {
          const isAlto = baseType === 'altostratus';
          const isNimbo = baseType === 'nimbostratus';
          const layerCount = isNimbo ? 4 : (isAlto ? 3 + Math.floor(Math.random() * 3) : 2 + Math.floor(Math.random() * 3));
          
          for (let L = 0; L < layerCount; L++) {
            const radius = (isNimbo ? 28 + Math.random() * 10 : (isAlto ? 18 + Math.random() * 26 : 10 + Math.random() * 20));
            const thickness = (isNimbo ? 2.0 + Math.random() * 1.2 : (isAlto ? 1.3 + Math.random() * 1.4 : 0.7 + Math.random() * 0.8));
            // Use wide, flattened spheres for a more volumetric sheet appearance than cylinders
            const puffCount = isNimbo ? 24 : 16;
            const yOffset = (L - layerCount / 2) * thickness * 0.8;
            
            for (let i = 0; i < puffCount; i++) {
              const ang = (i / puffCount) * Math.PI * 2 + Math.random() * 0.4;
              const r = radius * (0.5 + Math.random() * 0.5);
              const size = thickness * (0.8 + Math.random() * 0.4);
              
              let dens = isNimbo ? 0.75 : (isAlto ? 0.65 : 0.5);
              let moisture = isNimbo ? 0.95 : (isAlto ? 0.85 : 0.7);
              
              const pos = new THREE.Vector3(
                Math.cos(ang) * r,
                yOffset + (Math.random() - 0.5) * thickness * 0.5,
                Math.sin(ang) * r
              );
              makePuff(size, pos, dens, moisture);
            }
          }

          group.userData.canPrecipitate = true;
          group.userData.precipitationThreshold = isNimbo ? 0.35 : (isAlto ? 0.75 : 0.85);
          group.userData.moisture = (isNimbo ? 0.85 : (isAlto ? 0.62 + Math.random() * 0.14 : 0.58 + Math.random() * 0.12));
          group.userData.alwaysPrecipitate = isNimbo;
          // Set up initial emitter if precipitating
          if (group.userData.alwaysPrecipitate || (this.humidity > 55 && Math.random() < 0.45)) {
            group.userData.precipitating = true;
            group.userData.precipitationIntensity = 0.06 + Math.random() * (isNimbo ? 0.3 : 0.12);
            group.userData.rainEmitter = {
              position: new THREE.Vector3(group.position.x, Math.max(0.6, group.position.y - 1.2), group.position.z),
              height: isNimbo ? 4.0 : 2.0,
              radius: isNimbo ? 8.0 : 4.0,
              opacity: 0.6,
              ageFade: 0.0
            };
          }
          return;
        }
        
        // --- Cirrus (Sprite) ---
        if (baseType === 'cirrus') {
          const haloTex = createHaloTexture(256, 'rgba(255,245,220,1.0)');
          const haloMat = new THREE.SpriteMaterial({ map: haloTex, color: 0xffffff, transparent: true, opacity: 0.0, depthTest: false, blending: THREE.AdditiveBlending });
          const sprite = new THREE.Sprite(haloMat);
          sprite.scale.set(14, 14, 1);
          sprite.position.set(0, 0.2, 0);
          sprite.renderOrder = 999;
          group.add(sprite);
          group.userData.halo = sprite;
          group.userData.haloTex = haloTex;
          return;
        }

        // --- Derecho (Squall Line) ---
        if (baseType === 'derecho') {
          group.userData.isSquallLine = true;
          const bowLength = 80 + Math.random() * 60;
          const bowWidth = 12 + Math.random() * 6;
          const curvature = 0.004 + Math.random() * 0.002;
          group.userData.bow = { length: bowLength, width: bowWidth, curvature, heading: Math.random() * Math.PI * 2 };

          const bowCenter = new THREE.Vector3(0, 0, 0);
          function bowPosition(s, offsetZ = 0) {
            const x = (bowLength * 0.5) * s;
            const z = -Math.pow(s, 2) * bowLength * curvature * 40 + offsetZ;
            return new THREE.Vector3(x, 0, z);
          }

          // 1) Leading-edge shelf cloud / arcus band (made of flattened puffs)
          const shelfSegments = 24;
          for (let i = 0; i < shelfSegments; i++) {
            const t = i / (shelfSegments - 1);
            const s = t * 2 - 1; // [-1,1]
            const centerPos = bowPosition(s, 0);
            const segRadius = bowWidth * THREE.MathUtils.lerp(0.7, 1.1, Math.abs(s));
            const puffCount = 4 + Math.floor(Math.random() * 3);
            for (let p = 0; p < puffCount; p++) {
              const ang = (p / puffCount) * Math.PI * 2;
              const r = segRadius * (0.5 + Math.random() * 0.5);
              const size = 1.6 + Math.random() * 0.8;
              const dens = 0.72 + Math.random() * 0.1;
              const pos = new THREE.Vector3(
                centerPos.x + Math.cos(ang) * r * 0.8,
                0.4 + Math.random() * 0.8,
                centerPos.z + Math.sin(ang) * r * 0.2 // Flattened shape
              );
              makePuff(size, pos, dens, 0.92);
            }
          }
          
          // 2) Embedded convective cores (towers)
          const coreTowerCount = 6 + Math.floor(Math.random() * 5);
          for (let i = 0; i < coreTowerCount; i++) {
            const centerBias = (i < 2);
            const s = centerBias ? (Math.random() * 0.4 - 0.2) : (Math.random() * 2 - 1);
            const basePos = bowPosition(s, -0.4);

            const towerHeight = 4.5 + Math.random() * 4.0;
            const baseRadius = 4.0 + Math.random() * 2.5;
            const layers = 4 + Math.floor(Math.random() * 3);

            for (let l = 0; l < layers; l++) {
              const frac = l / Math.max(1, layers - 1);
              const radius = baseRadius * (1.0 - frac * 0.45);
              const y = 1.2 + frac * towerHeight + (Math.random() - 0.5) * 0.6;
              const puffCount = 5 + Math.floor(Math.random() * 4);
              for (let p = 0; p < puffCount; p++) {
                const ang = (p / puffCount) * Math.PI * 2 + Math.random() * 0.4;
                const rr = radius * (0.6 + Math.random() * 0.6);
                const size = 1.5 + Math.random() * 1.4;
                makePuff(size, 
                  new THREE.Vector3(
                    basePos.x + Math.cos(ang) * rr,
                    y,
                    basePos.z + Math.sin(ang) * rr
                  ), 0.95, 0.96);
              }
            }
          }

          // 3) Trailing stratiform shield (broad, flatter cloud region behind the line)
          const shieldRadius = bowLength * 0.55;
          const shieldLayers = 3;
          for (let l = 0; l < shieldLayers; l++) {
            const yOffset = l * 0.8 - 1.0;
            const puffCount = 40;
            for (let p = 0; p < puffCount; p++) {
              const ang = Math.random() * Math.PI * 2;
              const r = shieldRadius * Math.sqrt(Math.random());
              const size = 1
            }
          }

          // 4) Strong, continuous precipitation focused under the bow, with broader shield rain
          group.userData.canPrecipitate = true;
          group.userData.alwaysPrecipitate = true;
          group.userData.precipitating = true;
          group.userData.precipitationIntensity = 0.75 + Math.random() * 0.2;
          group.userData.precipitationThreshold = 0.2;
          group.userData.rainEmitter = {
            position: new THREE.Vector3(group.position.x, Math.max(0.6, group.position.y - 1.8), group.position.z),
            height: 4.4,
            radius: bowLength * 0.55, // covers main bow region
            opacity: 0.97,
            ageFade: 0.0
          };
          return;
        }

        // --- Reworked Cumuliform Structure Generation ---

        // Determine parameters based on cloud type
        let basePuffs = 4, maxLayers = 2, baseRadius = 3, verticalScale = 1.0;
        let requiresAnvil = false;

        if (type === 'cumulus_humilis') {
            // Fair-weather cumulus: shallow, wide, flat-bottomed
            basePuffs = 5 + Math.floor(Math.random() * 3);
            maxLayers = 1;
            baseRadius = 4.0 + Math.random() * 3.0;
            verticalScale = 0.5; // very limited vertical growth
        } else if (type === 'nimbostratus') {
            // Layered precipitation cloud (deep uniform sheet)
            basePuffs = 8 + Math.floor(Math.random() * 4);
            maxLayers = 3;
            baseRadius = 10 + Math.random() * 6;
            verticalScale = 1.2;
        } else if (type === 'cumulus_congestus') {
            // Developing towering cumulus with multiple domes
            basePuffs = 10 + Math.floor(Math.random() * 5);
            maxLayers = 5 + Math.floor(Math.random() * 2); // deep stacks
            baseRadius = 5 + Math.random() * 3;
            verticalScale = 2.5; // strong vertical development
        } else if (type === 'cumulonimbus') {
            // Deep thunderstorm pillar, anvil-topped
            basePuffs = 12 + Math.floor(Math.random() * 6);
            maxLayers = 8 + Math.floor(Math.random() * 2);
            baseRadius = (6 + Math.random() * 3) * 1.6;
            verticalScale = 3.6; // very tall
            requiresAnvil = true;
            group.userData.maxAge = 1200 + Math.random() * 600;
        } else if (type === 'supercell') {
            // Supercell: sculpted rotating tower with wide base and large anvil
            basePuffs = 18 + Math.floor(Math.random() * 8);
            maxLayers = 9 + Math.floor(Math.random() * 2);
            baseRadius = (7 + Math.random() * 3) * 2.2; // broad base
            verticalScale = 4.2; // extremely tall
            requiresAnvil = true;
            group.userData.maxAge = 1800 + Math.random() * 900;
            group.userData.mesocyclone = true;
        }

        // Introduce a simple shear profile per cloud to add tilt/lean with height
        // Store shear vector in userData so later evolution can reference it
        if (!group.userData.shear) {
          const shearAngle = Math.random() * Math.PI * 2;
          const shearMag =
            type === 'supercell'
              ? 0.9 + Math.random() * 0.7
              : type === 'cumulonimbus'
                ? 0.6 + Math.random() * 0.5
                : type === 'cumulus_congestus'
                  ? 0.3 + Math.random() * 0.3
                  : 0.1 + Math.random() * 0.2;
          group.userData.shear = {
            dir: new THREE.Vector2(Math.cos(shearAngle), Math.sin(shearAngle)),
            mag: shearMag
          };
        }

        // Optionally create 1‚Äì3 "core towers" for big storms: these are vertical columns with extra detail
        const coreTowerCount =
          (type === 'cumulonimbus' || type === 'supercell')
            ? 2 + Math.floor(Math.random() * 2)
            : (type === 'cumulus_congestus' ? 1 + Math.floor(Math.random() * 2) : 0);
        const coreTowers = [];
        for (let i = 0; i < coreTowerCount; i++) {
          const ang = (i / Math.max(1, coreTowerCount)) * Math.PI * 2 + Math.random() * 0.6;
          const r = baseRadius * (0.35 + Math.random() * 0.4);
          coreTowers.push({
            baseOffset: new THREE.Vector3(
              Math.cos(ang) * r,
              0,
              Math.sin(ang) * r
            ),
            radiusScale: 0.65 + Math.random() * 0.4,
            heightBias: 0.8 + Math.random() * 0.4
          });
        }

        // Build the main vertical structure (applies to all non-pyro/stratus/derecho)
        if (type !== 'cirrus') {
            for (let l = 0; l < maxLayers; l++) {
                // normalized layer index [0,1]
                const layerFrac = l / Math.max(1, maxLayers - 1);

                // Apply shear: higher layers are shifted more in the shear direction
                let shearOffset = new THREE.Vector3(0, 0, 0);
                if (group.userData.shear) {
                  const sMag = group.userData.shear.mag;
                  const sDir = group.userData.shear.dir;
                  // supercells tilt more aggressively with height
                  const heightTilt = THREE.MathUtils.lerp(0.0, (type === 'supercell' ? 8.0 : 5.0) * sMag, Math.pow(layerFrac, 1.1));
                  shearOffset.set(
                    sDir.x * heightTilt,
                    0,
                    sDir.y * heightTilt
                  );
                }

                // Ensure bottom layer is wider than top
                const layerRadius =
                  baseRadius *
                  (1.0 - Math.pow(layerFrac, 1.4) * 0.7) *
                  (1.0 + (type === 'supercell' ? 0.2 * Math.sin(layerFrac * Math.PI * 2.0) : 0.0));

                // Vertical spacing depends on verticalScale
                const layerY = l * 2.4 * verticalScale / Math.max(1, maxLayers - 0.5);

                // Puff size scales with radius; smaller higher up for congestus / nimbus detail
                const sizeFactor = (type === 'cumulus_congestus' || type === 'cumulonimbus' || type === 'supercell') ? 0.7 : 1.0;
                const basePuffSize = (1.4 + Math.random() * 1.6) * baseRadius / 8 * sizeFactor;

                const puffsThisLayer =
                  type === 'cumulus_humilis'
                    ? basePuffs
                    : basePuffs + Math.floor(l * 0.4); // more domes higher in deep towers

                // Randomly carve a few "entrainment pockets" (holes) in large storm layers for more texture
                const entrainHoles =
                  (type === 'cumulonimbus' || type === 'supercell') && layerRadius > baseRadius * 0.7
                    ? 1 + Math.floor(Math.random() * 3)
                    : 0;
                const entrainAngles = [];
                for (let eh = 0; eh < entrainHoles; eh++) {
                  entrainAngles.push(Math.random() * Math.PI * 2);
                }
                const entrainWidth = Math.PI / 6;

                for (let i = 0; i < puffsThisLayer; i++) {
                    const baseAngle = (i / puffsThisLayer) * Math.PI * 2 + l * 0.5;
                    let a = baseAngle + (Math.random() - 0.5) * 0.25;

                    // Skip some puffs near entrainment angles to create visible gaps
                    let skip = false;
                    for (let ea = 0; ea < entrainAngles.length; ea++) {
                      const dAng = Math.abs(angleDifference(a, entrainAngles[ea]));
                      if (dAng < entrainWidth * (0.7 + Math.random() * 0.6)) {
                        if (Math.random() < 0.5) skip = true;
                        break;
                      }
                    }
                    if (skip) continue;

                    const r =
                      Math.random() * layerRadius *
                      (type === 'cumulus_humilis' ? 1.0 : 0.85) *
                      (0.9 + Math.random() * 0.25);

                    // Base darkening for deep convection bottom layer
                    const baseDarken = (type === 'cumulus_congestus' || type === 'cumulonimbus' || type === 'supercell') && l === 0;
                    const densBase = baseDarken ? 0.9 : 0.8;
                    let dens =
                      THREE.MathUtils.lerp(densBase, 0.65, layerFrac) +
                      Math.random() * 0.1;

                    // Flat base for humilis, stronger relief for congestus / nimbus
                    const yJitter =
                      type === 'cumulus_humilis'
                        ? 0.2
                        : (type === 'cumulus_congestus' ? 0.8 : 1.0);

                    // Give top layers small "turrets" for congestus/nimbus
                    let puffSize = basePuffSize * (0.9 + Math.random() * 0.3);
                    if ((type === 'cumulus_congestus' || type === 'cumulonimbus' || type === 'supercell') && layerFrac > 0.55) {
                      puffSize *= 0.8 + Math.random() * 0.6;
                      dens += 0.05;
                    }

                    const pos = new THREE.Vector3(
                      Math.cos(a) * r,
                      layerY + Math.random() * yJitter,
                      Math.sin(a) * r
                    ).add(shearOffset);

                    // Slightly bias some puffs onto core towers for towering updraft pillars
                    if (coreTowers.length && (type === 'cumulonimbus' || type === 'supercell' || type === 'cumulus_congestus')) {
                      if (Math.random() < 0.25) {
                        const tIndex = Math.floor(Math.random() * coreTowers.length);
                        const tower = coreTowers[tIndex];
                        const towerFrac = Math.pow(layerFrac, tower.heightBias);
                        const towerRadius = layerRadius * tower.radiusScale * 0.7;
                        const towerAngle = tower.baseOffset.angleTo
                          ? tower.baseOffset
                          : null;
                        const tAng = towerAngle
                          ? towerAngle
                          : (Math.random() * Math.PI * 2);
                        const tPos = new THREE.Vector3(
                          tower.baseOffset.x + Math.cos(tAng) * towerRadius * 0.25,
                          layerY * tower.heightBias + Math.random() * 0.6,
                          tower.baseOffset.z + Math.sin(tAng) * towerRadius * 0.25
                        );
                        pos.copy(tPos.add(shearOffset));
                        puffSize *= 1.1;
                        dens += 0.05;
                      }
                    }

                    makePuff(
                      puffSize,
                      pos,
                      dens
                    );
                }
            }

            // Slight extra low-level base disc for congestus / nimbus to hint dark base
            if (type === 'cumulus_congestus' || type === 'cumulonimbus' || type === 'supercell') {
              const baseDiscRadius = baseRadius * 0.9;
              const baseDiscGeom = new THREE.CylinderGeometry(baseDiscRadius, baseDiscRadius, 0.8, 20);
              const baseDiscMat = createCloudMaterial();
              baseDiscMat.uniforms.density.value = 0.0;
              baseDiscMat.userData = baseDiscMat.userData || {};
              baseDiscMat.userData.targetDensity = 0.9;
              baseDiscMat.uniforms.moisture.value = 0.95;
              baseDiscMat.uniforms.shadowColor.value = new THREE.Color(0x3b3f46);
              baseDiscMat.uniforms.lightColor.value = new THREE.Color(0xf0f0f0);
              const baseDisc = new THREE.Mesh(baseDiscGeom, baseDiscMat);
              baseDisc.position.y = 0.0;
              baseDisc.position.add(group.userData.shear ? new THREE.Vector3(group.userData.shear.dir.x, 0, group.userData.shear.dir.y).multiplyScalar(0.5) : new THREE.Vector3());
              group.add(baseDisc);
              group.userData.structureElements.push(baseDisc);
            }

            group.userData.verticalGrowth = verticalScale; // Track initial scale

            // Add overshooting top dome for the strongest storms
            if (requiresAnvil && (type === 'cumulonimbus' || type === 'supercell')) {
              const overshootSize = baseRadius * (type === 'supercell' ? 1.2 : 0.9);
              const overshoot = new THREE.Mesh(
                new THREE.SphereGeometry(overshootSize, 18, 18),
                createCloudMaterial()
              );
              overshoot.material.uniforms.density.value = 0.0;
              overshoot.userData = overshoot.userData || {};
              overshoot.userData.targetDensity = 0.82;
              overshoot.material.uniforms.moisture.value = 0.96;
              overshoot.material.uniforms.shadowColor.value = new THREE.Color(0x4a4f58);
              overshoot.material.uniforms.lightColor.value = new THREE.Color(0xffffff);
              overshoot.position.set(
                (group.userData.shear ? group.userData.shear.dir.x * 4.0 : 0),
                maxLayers * 2.4 * verticalScale / Math.max(1, maxLayers - 0.5) + 2.0,
                (group.userData.shear ? group.userData.shear.dir.y * 4.0 : 0)
              );
              group.add(overshoot);
              group.userData.structureElements.push(overshoot);
            }

            if (requiresAnvil) {
                // Supercells get a significantly larger anvil
                const anvilScaleBoost = (type === 'supercell' ? 2.1 : 1.6);
                const anvilRadius = baseRadius * anvilScaleBoost;
                // Anvil sits high up, above the highest puff layer
                const anvilY = maxLayers * 2.4 * verticalScale / Math.max(1, maxLayers - 0.5);

                // Note: using anvilRadius * 0.8 as top radius and anvilRadius * 1.0 as bottom radius to simulate spreading/flared anvil top geometry
                const anvilGeom = new THREE.CylinderGeometry(anvilRadius * 0.8, anvilRadius * 1.0, 1.0, 32);
                const anvilMat = createCloudMaterial();
                // initialize anvil fade-in
                anvilMat.uniforms.density.value = 0.0;
                anvilMat.userData = anvilMat.userData || {};
                anvilMat.userData.targetDensity = 0.72;
                anvilMat.uniforms.moisture.value = 0.82;
                anvilMat.uniforms.shadowColor.value = new THREE.Color(0x7a7f88);
                anvilMat.uniforms.lightColor.value = new THREE.Color(0xffffff);
                const anvil = new THREE.Mesh(anvilGeom, anvilMat);
                // Move anvil slightly above the structure top and in the shear direction
                anvil.position.y = anvilY + 0.5 * verticalScale;
                if (group.userData.shear) {
                  anvil.position.x += group.userData.shear.dir.x * group.userData.shear.mag * 4.0;
                  anvil.position.z += group.userData.shear.dir.y * group.userData.shear.mag * 4.0;
                }
                group.add(anvil);
                group.userData.anvil = anvil;
                group.userData.anvilHeight = anvil.position.y;
                
                // create anvil emitter/light placeholders
                group.userData.anvilEmitter = { position: new THREE.Vector3(group.position.x, group.position.y + anvil.position.y, group.position.z), height: 2.6, radius: anvilRadius * 0.8, opacity: 1.0 };
                const pl = new THREE.PointLight(0xfff8ee, 0.0, 24, 2);
                pl.position.set(group.position.x, group.position.y + anvil.position.y + 1.0, group.position.z);
                pl.userData = { life: 0.0 };
                scene.add(pl);
                group.userData.anvilLight = pl;
                group.userData.anvilPrecipIntensity = THREE.MathUtils.clamp(group.userData.precipitationIntensity + 0.25, 0, 1.0);
            }

            // For supercells, add a subtle flanking line of smaller congestus towers feeding into the main updraft
            if (type === 'supercell') {
              const flankCount = 3 + Math.floor(Math.random() * 3);
              const flankSide = (Math.random() < 0.5 ? -1 : 1);
              for (let fi = 0; fi < flankCount; fi++) {
                const frac = fi / Math.max(1, flankCount - 1);
                const offsetDist = baseRadius * (1.2 + frac * 1.4);
                const baseY = 0.4 + frac * 2.0;
                const ang = (group.userData.shear ? Math.atan2(group.userData.shear.dir.y, group.userData.shear.dir.x) + flankSide * Math.PI / 2 : Math.random() * Math.PI * 2);
                const flankPos = new THREE.Vector3(
                  Math.cos(ang) * offsetDist,
                  baseY,
                  Math.sin(ang) * offsetDist
                );
                const towerLayers = 2 + Math.floor(Math.random() * 2);
                for (let fl = 0; fl < towerLayers; fl++) {
                  const tFrac = fl / Math.max(1, towerLayers - 1);
                  const tRadius = baseRadius * 0.4 * (1.0 - tFrac * 0.6);
                  const puffCount = 3 + Math.floor(Math.random() * 3);
                  for (let pi = 0; pi < puffCount; pi++) {
                    const a = (pi / puffCount) * Math.PI * 2 + Math.random() * 0.6;
                    const r = tRadius * (0.5 + Math.random() * 0.5);
                    const size = baseRadius * 0.25 * (0.9 + Math.random() * 0.4);
                    const dens = 0.78 + Math.random() * 0.12;
                    const pos = new THREE.Vector3(
                      flankPos.x + Math.cos(a) * r,
                      flankPos.y + tFrac * 2.0 + Math.random() * 0.5,
                      flankPos.z + Math.sin(a) * r
                    );
                    makePuff(size, pos, dens);
                  }
                }
              }
            }
        }
        
        if (type === 'cirrus') {
          // Add subtle halo sprite for high thin clouds (cirrus/cirrostratus-like)
          const haloTex = createHaloTexture(256, 'rgba(255,245,220,1.0)');
          const haloMat = new THREE.SpriteMaterial({ map: haloTex, color: 0xffffff, transparent: true, opacity: 0.0, depthTest: false, blending: THREE.AdditiveBlending });
          const sprite = new THREE.Sprite(haloMat);
          sprite.scale.set(14, 14, 1);
          sprite.position.set(0, 0.2, 0);
          sprite.renderOrder = 999;
          group.add(sprite);
          group.userData.halo = sprite;
          group.userData.haloTex = haloTex;
        }
        // If this cloud was flagged pyro, bias its moisture/precipitation/heavy-flash potential
        if (group.userData && group.userData.pyro) {
          group.userData.moisture = Math.min(1.0, (group.userData.moisture || 0.5) + 0.18 + Math.random()*0.08);
          // make pyro clouds more likely to precipitate strongly and have heavier emitters
          group.userData.precipitating = true;
          group.userData.precipitationIntensity = THREE.MathUtils.clamp(0.45 + Math.random() * 0.35, 0.35, 1.0);
          group.userData.rainEmitter = {
            position: new THREE.Vector3(group.position.x, Math.max(0.6, group.position.y - 2.2), group.position.z),
            height: 5.0,
            radius: 8.0 + (group.userData.baseScale || 1.0) * 3.0,
            opacity: 1.0,
            ageFade: 0.0
          };
        }
      }
      // Cloud type evolution from fair-weather to deep convection
      maybeMatureCloud(cloud) {
        const t = this.temperature;
        const h = this.humidity;
        const ud = cloud.userData;
        if (ud.type === 'cumulus_humilis' && ud.moisture > 0.55 && h > 60 && t > 12) {
          ud.type = 'cumulus_congestus';
          ud.canPrecipitate = true;
          ud.alwaysPrecipitate = false;
          ud.precipitationThreshold = 0.5;
          for (let i = 0; i < 4; i++) {
            const a = Math.random() * Math.PI * 2;
            const puff = new THREE.Mesh(new THREE.SphereGeometry(2.5 + Math.random() * 1.5, 12, 12), createCloudMaterial());
            puff.material.uniforms.density.value = 0.9;
            puff.material.uniforms.moisture.value = 0.9;
            puff.position.set(Math.cos(a) * (2 + Math.random() * 3), 3 + Math.random() * 4, Math.sin(a) * (2 + Math.random() * 3));
            cloud.add(puff);
            ud.structureElements.push(puff);
          }
        } else if (ud.type === 'cumulus_congestus' && ud.moisture > 0.65 && h > 70 && t > 18) {
          ud.type = 'cumulonimbus';
          ud.canPrecipitate = true;
          ud.alwaysPrecipitate = true;
          ud.precipitationThreshold = 0.3;
          for (let i = 0; i < 6; i++) {
            const a = Math.random() * Math.PI * 2;
            const puff = new THREE.Mesh(new THREE.SphereGeometry(3 + Math.random() * 2, 14, 14), createCloudMaterial());
            puff.material.uniforms.density.value = 0.92;
            puff.material.uniforms.moisture.value = 0.95;
            puff.position.set(Math.cos(a) * (4 + Math.random() * 5), 6 + Math.random() * 6, Math.sin(a) * (4 + Math.random() * 5));
            cloud.add(puff);
            ud.structureElements.push(puff);
          }
          // create anvil topping for deep convection
          if (!ud.anvil) {
            // Anvil needs to reflect the current tall structure driven by verticalGrowth
            const baseScale = cloud.userData.baseScale || 1.0;
            // Estimate height based on vertical growth tracked in update loop (where 1.0 is default, 3.5 is max in that calculation)
            const estimatedVertScale = THREE.MathUtils.clamp(ud.verticalGrowth, 0.5, 3.5); 
            const anvilRadius = 10 + baseScale * 6;
            
            const anvilGeom = new THREE.CylinderGeometry(anvilRadius, anvilRadius * 1.1, 1.0, 32);
            const anvilMat = createCloudMaterial();
            anvilMat.uniforms.density.value = 0.0;
            anvilMat.userData = anvilMat.userData || {};
            anvilMat.userData.targetDensity = 0.72;
            anvilMat.uniforms.moisture.value = 0.82;
            anvilMat.uniforms.shadowColor.value = new THREE.Color(0x7a7f88);
            anvilMat.uniforms.lightColor.value = new THREE.Color(0xffffff);
            const anvil = new THREE.Mesh(anvilGeom, anvilMat);
            anvil.rotation.x = 0;
            // Position anvil high up based on estimated scale, ensuring it towers.
            anvil.position.y = 8.5 + estimatedVertScale * 2.5; 
            cloud.add(anvil);
            ud.anvil = anvil;
            // create anvil emitter/light placeholders
            ud.anvilEmitter = { position: new THREE.Vector3(cloud.position.x, cloud.position.y + anvil.position.y, cloud.position.z), height: 2.6, radius: anvilRadius * 0.6, opacity: 1.0 };
            const pl = new THREE.PointLight(0xfff8ee, 0.0, 24, 2);
            pl.position.set(cloud.position.x, cloud.position.y + anvil.position.y + 0.5, cloud.position.z);
            pl.userData = { life: 0.0 };
            scene.add(pl);
            ud.anvilLight = pl;
            ud.anvilPrecipIntensity = Math.min(1.0, ud.precipitationIntensity + 0.25);
          } else {
            // If anvil exists (likely initialized in buildInitialStructure), update height dynamically
            const estimatedVertScale = THREE.MathUtils.clamp(ud.verticalGrowth, 0.5, 3.5);
            const newY = 8.5 + estimatedVertScale * 2.5;
            ud.anvil.position.y += (newY - ud.anvil.position.y) * 0.1;
            
            // horizontal scale adjust
            const baseScale = cloud.userData.baseScale || 1.0;
            ud.anvil.scale.set(1.25 * baseScale, 1, 1.25 * baseScale);
            ud.anvilPrecipIntensity = Math.min(1.0, ud.precipitationIntensity + 0.25);
          }
        }
      }
      update(deltaTime, windSystem) {
        // increase allowed cloud population and spawn probability
        if (this.clouds.length < 390 && Math.random() < this.humidity * this.evaporationRate / 1500) {
          this.createCloud();
        }
        // Calculate environmental instability (proxy for updraft strength)
        // High temp (>15C) and High humidity (>60%) drive instability
        const tempFactor = THREE.MathUtils.clamp((this.temperature - 15) / 10, 0, 1.5);
        const humidityFactor = THREE.MathUtils.clamp((this.humidity - 60) / 30, 0, 1.0);
        const instability = tempFactor * 0.5 + humidityFactor * 0.5;
        const updraftRate = 0.3 * instability * state.controls.simulationSpeed; // Base rate multiplier

        for (let i = this.clouds.length - 1; i >= 0; i--) {
          const c = this.clouds[i];
          c.userData.age += deltaTime;
          const lr = c.userData.age / c.userData.maxAge;
          
          const minAllowedY = Math.max(0.6, c.userData.initialY * 0.5);
          if (c.position.y < minAllowedY) {
            c.position.y = Math.max(minAllowedY, c.position.y + 0.06);
          }
          
          // Updraft system integration: primarily affecting cumuliform clouds
          let verticalGrowthDrive = 0;
          if (c.userData.type.includes('cumulus') || c.userData.type.includes('nimbus') || c.userData.type.includes('cell')) {
            // Apply upward push based on instability (updraft)
            const push = updraftRate * (c.userData.moisture || 0.5) * 0.5;
            c.position.y += push * deltaTime;
            
            // Drive vertical scale growth potential
            verticalGrowthDrive = updraftRate * 0.5 + 0.5; // Scale base growth if unstable
          }

          
          if (lr < 0.25) {
            c.userData.stage = 'forming';
            const t = lr / 0.25;
            const ease = t * t * (3 - 2 * t);
            const s = 0.12 + ease * 0.45;
            c.scale.set(s * c.userData.baseScale, s * c.userData.baseScale, s * c.userData.baseScale);
            c.userData.condensationLevel += deltaTime * 0.012 * (this.humidity / 100) * this.evaporationRate;
            // Accumulate vertical growth potential during formation
            c.userData.verticalGrowth = THREE.MathUtils.clamp(c.userData.verticalGrowth + verticalGrowthDrive * deltaTime * 0.1, 0, 1.0);

            if (c.userData.condensationLevel > 0.25 && Math.random() < 0.02 && c.userData.structureElements.length < 60) {
              const a = Math.random() * Math.PI * 2;
              const puff = new THREE.Mesh(new THREE.SphereGeometry(2.5 + Math.random() * 1.5, 12, 12), createCloudMaterial());
              puff.material.uniforms.density.value = 0.88 + Math.random() * 0.08;
              puff.material.uniforms.moisture.value = 0.85 + Math.random() * 0.15;
              puff.position.set(Math.cos(a) * (3 + Math.random() * 4), Math.random() * 6, Math.sin(a) * (3 + Math.random() * 4));
              c.add(puff);
              c.userData.structureElements.push(puff);
            }
          } else if (lr < 0.6) {
            c.userData.stage = 'mature';
            // Increase vertical growth potential during maturity based on environment
            c.userData.verticalGrowth = THREE.MathUtils.clamp(c.userData.verticalGrowth + verticalGrowthDrive * deltaTime * 0.2, 0, 3.0);
            
            const t = (lr - 0.25) / (0.35);
            const expand = 1 + Math.pow(t, 0.9) * 3.0; // horizontal expansion still tied to age
            const vert = 1 + THREE.MathUtils.clamp(c.userData.verticalGrowth, 0.5, 3.5) * 2.8; // vertical scale driven by accumulated growth

            c.scale.set(expand * c.userData.baseScale, vert * c.userData.baseScale, expand * c.userData.baseScale);
            c.userData.moisture += deltaTime * 0.0012;
            this.maybeMatureCloud(c);
            if (c.userData.alwaysPrecipitate && c.userData.canPrecipitate) {
              c.userData.precipitating = true;
              c.userData.precipitationIntensity = Math.min(1, c.userData.moisture * 1.3);
              c.userData.moisture = Math.max(0.35, c.userData.moisture - deltaTime * 0.001);
            } else {
              if (c.userData.moisture > 0.6 && Math.random() < (this.humidity / 500)) {
                c.userData.precipitating = true;
                c.userData.precipitationIntensity = Math.min(0.9, c.userData.moisture);
              }
            }
            if (c.userData.anvil) {
              c.userData.anvilPrecipIntensity = THREE.MathUtils.clamp((c.userData.precipitationIntensity || 0) + 0.25, 0, 1);
              if (c.userData.precipitating) {
                c.userData.precipitationIntensity = Math.min(1.0, c.userData.precipitationIntensity + 0.08 * deltaTime);
              }
              if (c.userData.precipitating && c.userData.anvilLight && Math.random() < 0.0009 * (c.userData.precipitationIntensity || 0.6) * 300 * deltaTime) {
                c.userData.anvilLight.intensity = 2.6 + Math.random() * 3.4;
              }
            }
          } else {
            c.userData.precipitating = false;
            const humidityFactor = THREE.MathUtils.clamp(this.humidity / 100, 0.2, 1.0);
            const fadeBase = Math.max(0, 1 - ((lr - 0.6) / 0.4));
            const fade = fadeBase * humidityFactor;
            c.userData.structureElements.forEach(e => e.material.uniforms.density.value = 0.9 * fade);
            c.scale.setScalar(0.9 * c.userData.baseScale * Math.max(0.15, fade));
          }
          
          c.userData.structureElements.forEach(e => {
            // if this element was set up with a target density, smoothly interpolate its density toward that target
            const mat = e.material;
            if (mat) {
              const current = mat.uniforms.density.value !== undefined ? mat.uniforms.density.value : 1.0;
              // determine target density (element-level userData or material-level userData)
              let target = 1.0;
              if (e.userData && e.userData.targetDensity !== undefined) target = e.userData.targetDensity;
              else if (mat.userData && mat.userData.targetDensity !== undefined) target = mat.userData.targetDensity;
              // compute lerp factor scaled by dt to keep animation framerate independent
              const lerpFactor = Math.min(1, deltaTime * 1.2);
              mat.uniforms.density.value = THREE.MathUtils.lerp(current, target, lerpFactor);
              mat.uniforms.moisture.value = c.userData.moisture;
              if (mat.uniforms.time) mat.uniforms.time.value = Date.now() * 0.001;
            }
          });
          
          const wind = windSystem.getWindAtAltitude(c.position.y);
          c.position.x += wind.x * state.controls.windSpeed;
          c.position.z += wind.y * state.controls.windSpeed;
          // increase wrap bound to match expanded spawn area so clouds smoothly circulate
          const WRAP_BOUND = 4800;
          if (c.position.x > WRAP_BOUND) c.position.x = -WRAP_BOUND;
          if (c.position.x < -WRAP_BOUND) c.position.x = WRAP_BOUND;
          if (c.position.z > WRAP_BOUND) c.position.z = -WRAP_BOUND;
          if (c.position.z < -WRAP_BOUND) c.position.z = WRAP_BOUND;
          
          if (lr >= 1) {
            if (c.userData.anvilLight) {
              scene.remove(c.userData.anvilLight);
              if (c.userData.anvilLight.dispose) c.userData.anvilLight.dispose();
            }
            scene.remove(c);
            c.userData.structureElements.forEach(e => {
              e.geometry.dispose();
              e.material.dispose();
            });
            this.clouds.splice(i, 1);
          }
          
          // Rain emitter logic
          if (c.userData.precipitating) {
            if (!c.userData.rainEmitter) {
              c.userData.rainEmitter = {
                position: new THREE.Vector3(),
                height: 4.0,
                radius: 3.0,
                opacity: 1.0,
                ageFade: 0.0
              };
            }
            const emitter = c.userData.rainEmitter;
            if (c.userData.anvil && !c.userData.anvilEmitter) {
              c.userData.anvilEmitter = { position: new THREE.Vector3(c.position.x, c.position.y + 10, c.position.z), height: 2.8, radius: Math.max(5, 6.0 * (c.userData.baseScale || 1)), opacity: 1.0 };
            }
            const baseY = Math.max(0.6, c.position.y - (c.scale.y * 1.8));
            emitter.position.set(c.position.x, baseY - emitter.height * 0.5, c.position.z);
            const intensity = c.userData.precipitationIntensity || 0.2;
            const typeMult = (c.userData.type === 'supercell' ? 1.8 : (c.userData.type === 'cumulonimbus' ? 1.25 : 1.0));
            emitter.radius = THREE.MathUtils.lerp(1.2, 6.0, intensity) * (1 + (c.scale.x * 0.55)) * typeMult;
            emitter.height = THREE.MathUtils.lerp(2.5, Math.max(6.0, c.scale.y * 2.5), intensity) * (0.9 + (c.scale.y * 0.06)) * typeMult;
            const ageFactor = THREE.MathUtils.clamp(c.userData.age / c.userData.maxAge, 0.0, 1.0);
            emitter.opacity = THREE.MathUtils.clamp(0.3 + intensity * 0.9 - ageFactor * 0.2, 0.04, 1.0);
            emitter.ageFade = ageFactor;

            // --- LIGHTNING: add weak lightning for cumulus_congestus and stronger for cumulonimbus ---
            // initialize lightning container
            if (!c.userData._lightnings) c.userData._lightnings = [];
            // lightning chance scales with intensity and type
            // increased lightning odds for deep convection
            let baseChance = 0;
            if (c.userData.type === 'cumulonimbus') baseChance = 0.18;
            else if (c.userData.type === 'supercell') baseChance = 0.12;
            else if (c.userData.type === 'cumulus_congestus') baseChance = 0.06;
            if (baseChance > 0 && Math.random() < baseChance * intensity * deltaTime * 60) {
              // choose lightning variant
              // IC is most common, then CG, then CC and CA
              const rKind = Math.random();
              let kind = 'IC';
              if (rKind < 0.55) kind = 'IC';
              else if (rKind < 0.85) kind = 'CG';
              else if (rKind < 0.95) kind = 'CC';
              else kind = 'CA';

              // if this is a pyro-cloud, increase odds of volcanic lightning and bias to orange CG/IC flashes
              let volcanicVariant = false;
              if (c.userData.pyro) {
                // raise chance for volcanic-style flash and bias to CG/IC
                if (Math.random() < 0.60) volcanicVariant = true;
                if (Math.random() < 0.45) kind = (Math.random() < 0.7 ? 'IC' : 'CG');
              }

              // determine start / end positions for the bolt
              const cloudCenter = c.position.clone();
              let startPos = new THREE.Vector3();
              let endPos = new THREE.Vector3();
              let isPositiveCG = false;

              // helper: random point near cloud at a given relative height
              const cloudRadius = (c.scale.x + c.scale.z) * 0.5;
              const randAroundCloud = (relY=0.0, spread=1.0) => {
                const ang = Math.random() * Math.PI * 2;
                const r = cloudRadius * (0.3 + Math.random() * 0.6) * spread;
                return new THREE.Vector3(
                  cloudCenter.x + Math.cos(ang) * r,
                  cloudCenter.y + relY,
                  cloudCenter.z + Math.sin(ang) * r
                );
              };

              if (kind === 'IC') {
                // Intra-cloud: entirely inside / across this cloud
                startPos = randAroundCloud(0, 0.7);
                endPos = randAroundCloud(0.6 * c.scale.y * 0.3, 0.9);
              } else if (kind === 'CG') {
                // Cloud-to-ground: from base or anvil to ground
                const fromAnvil = !!c.userData.anvil && (c.userData.type === 'supercell' || Math.random() < 0.4);
                const baseDrop = fromAnvil ? c.scale.y * 0.5 : c.scale.y * 0.8;
                startPos = randAroundCloud(fromAnvil ? baseDrop : -baseDrop * 0.25, 0.3);
                endPos = new THREE.Vector3(startPos.x + (Math.random() - 0.5) * 3.0, 0.6, startPos.z + (Math.random() - 0.5) * 3.0);
                // positive CG: stronger, from higher levels
                isPositiveCG = fromAnvil && Math.random() < 0.55;
                // volcanic CG tends to come from plume columns (slightly offset)
                if (volcanicVariant) {
                  // nudge bolt to originate deeper in plume area
                  startPos.x += (Math.random()-0.5)*2.0;
                  startPos.z += (Math.random()-0.5)*2.0;
                }
              } else if (kind === 'CC') {
                // Cloud-to-cloud: connect to another nearby storm cell if possible
                const partners = this.clouds.filter(o =>
                  o !== c &&
                  o.userData &&
                  (o.userData.type === 'cumulonimbus' || o.userData.type === 'supercell' || o.userData.type === 'cumulus_congestus') &&
                  o.position.distanceTo(c.position) < 220
                );
                let target = partners.length ? partners[Math.floor(Math.random() * partners.length)] : null;
                if (target) {
                  const targetCenter = target.position.clone();
                  startPos = randAroundCloud(0.3 * c.scale.y * 0.3, 0.8);
                  const tRad = (target.scale.x + target.scale.z) * 0.5;
                  const ang = Math.random() * Math.PI * 2;
                  const r = tRad * (0.3 + Math.random() * 0.6);
                  endPos = new THREE.Vector3(
                    targetCenter.x + Math.cos(ang) * r,
                    targetCenter.y + 0.3 * target.scale.y * 0.3,
                    targetCenter.z + Math.sin(ang) * r
                  );
                } else {
                  // fallback to intra-cloud
                  kind = 'IC';
                  startPos = randAroundCloud(0, 0.7);
                  endPos = randAroundCloud(0.6 * c.scale.y * 0.3, 0.9);
                }
              } else if (kind === 'CA') {
                // Cloud-to-air: one end sticks out into clear air near the cloud edge
                startPos = randAroundCloud(0.2 * c.scale.y * 0.3, 0.9);
                const dirAng = Math.random() * Math.PI * 2;
                const outDist = cloudRadius * (1.2 + Math.random() * 0.8);
                endPos = new THREE.Vector3(
                  startPos.x + Math.cos(dirAng) * outDist,
                  startPos.y + (Math.random() - 0.2) * 10.0,
                  startPos.z + Math.sin(dirAng) * outDist
                );
              }

              // flash strength / duration depends on type
              let flashPower;
              let flashRange;
              let life;
              if (kind === 'IC') {
                flashPower = (c.userData.type === 'cumulonimbus') ? (4.0 + Math.random() * 4.0) : (1.2 + Math.random() * 1.6);
                flashRange = (c.userData.type === 'cumulonimbus') ? 16 + Math.random() * 10 : 8 + Math.random() * 6;
                life = 0.18 + Math.random() * 0.3;
              } else if (kind === 'CG') {
                if (isPositiveCG) {
                  flashPower = 10.0 + Math.random() * 8.0;
                  flashRange = 28 + Math.random() * 14;
                  life = 0.55 + Math.random() * 0.4;
                } else {
                  flashPower = 6.0 + Math.random() * 5.0;
                  flashRange = 20 + Math.random() * 10;
                  life = 0.25 + Math.random() * 0.35;
                }
              } else if (kind === 'CC') {
                flashPower = 5.0 + Math.random() * 4.0;
                flashRange = 24 + Math.random() * 12;
                life = 0.35 + Math.random() * 0.4;
              } else { // CA
                flashPower = 3.0 + Math.random() * 3.0;
                flashRange = 20 + Math.random() * 10;
                life = 0.25 + Math.random() * 0.35;
              }

              // adjust for volcanic variant: orange, smokier, shorter range but punchy near plume
              let flashColor = 0xffffff;
              if (volcanicVariant) {
                flashColor = 0xff8a2b; // volcanic orange
                flashPower *= 0.9;
                flashRange *= 0.7;
                life *= 0.9;
              } else {
                flashColor = isPositiveCG ? 0xfff0cc : 0xffffee;
              }

              // spawn a localized flash (PointLight + optional line bolt)
              const flash = new THREE.PointLight(
                flashColor,
                flashPower,
                flashRange,
                2
              );
              // place flash roughly halfway along bolt path
              const mid = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);
              flash.position.copy(mid);
              flash.userData = {
                life,
                age: 0,
                initialIntensity: flashPower,
                kind,
                isPositiveCG,
                volcanic: volcanicVariant
              };

              // create visible bolt for CG / CC / CA, occasional for vivid IC
              let needsLine = (kind === 'CG' || kind === 'CC' || kind === 'CA');
              if (!needsLine && kind === 'IC' && Math.random() < 0.25) needsLine = true;

              if (needsLine) {
                const boltGeom = new THREE.BufferGeometry().setFromPoints([startPos, endPos]);
                const boltMat = new THREE.LineBasicMaterial({
                  color: volcanicVariant ? 0xffc08a : (isPositiveCG ? 0xffe0aa : 0xffffee),
                  transparent: true,
                  opacity: 1.0,
                  linewidth: 1
                });
                const bolt = new THREE.Line(boltGeom, boltMat);
                bolt.userData = {
                  life,
                  age: 0,
                  kind,
                  isPositiveCG,
                  volcanic: volcanicVariant
                };
                scene.add(bolt);
                flash.userData.line = bolt;
              }

              scene.add(flash);
              c.userData._lightnings.push(flash);

              // brief camera flash if nearby (stronger for CG)
              const distCam = mid.distanceTo(camera.position);
              if (distCam < 40) {
                const baseShake = (kind === 'CG' ? 0.9 : (kind === 'CC' ? 0.6 : 0.4));
                const camBoost = Math.min(0.8, (40 - distCam) / 40 * (flashPower * 0.05)) * baseShake * 5.0;
                camera.position.x += (Math.random() - 0.5) * camBoost;
                camera.position.y += (Math.random() - 0.5) * (camBoost * 0.7);
              }
            }
          } else {
            if (c.userData.rainEmitter) {
              c.userData.rainEmitter.opacity *= 0.92;
              if (c.userData.rainEmitter.opacity < 0.02) {
                c.userData.rainEmitter = null;
              }
            }
          }

          // Strong-cloud gust emission: supercells & derechos push localized strong wind bursts
          if ((c.userData.type === 'supercell' || c.userData.type === 'derecho') && c.userData.precipitating) {
            c.userData.lastGustTime -= deltaTime;
            if (c.userData.lastGustTime <= 0) {
              // compute gust power from precipitation intensity and cloud vertical scale
              const power = THREE.MathUtils.clamp((c.userData.precipitationIntensity || 0.2) * (c.scale.y * 0.35) + Math.random() * 0.25, 0, 1.6);
              // gust radius scales with cloud size and type
              const baseRadius = (c.userData.type === 'supercell') ? (12 + c.scale.x * 8) : (8 + c.scale.x * 6);
              const gustDir = new THREE.Vector3(wind.x, 0, wind.y).normalize();
              // apply gust to trees
              treeSystem.applyGustAt(c.position, baseRadius, gustDir, power);
              // camera shake when gust is strong and close
              const distToCamera = Math.hypot(c.position.x - camera.position.x, c.position.z - camera.position.z);
              if (distToCamera < baseRadius * 1.2) {
                const proximity = 1 - (distToCamera / (baseRadius * 1.2));
                const shakeMag = 0.6 * power * proximity * 3.0 * 5.0; // increased shake intensity
                camera.position.x += (Math.random() - 0.5) * shakeMag;
                camera.position.y += (Math.random() - 0.5) * (shakeMag * 0.5);
              }
              // set cooldown
              c.userData.lastGustTime = c.userData.gustCooldown + Math.random()*3;
            }
          }
          // end of cloud loop
          // Update lightning life for this cloud (decay and cleanup)
          if (c.userData._lightnings && c.userData._lightnings.length > 0) {
            for (let li = c.userData._lightnings.length - 1; li >= 0; li--) {
              const L = c.userData._lightnings[li];
              if (!L) { c.userData._lightnings.splice(li,1); continue; }
              L.userData.age += deltaTime;
              // quick intensity decay curve
              const tL = L.userData.age / Math.max(0.0001, L.userData.life);
              L.intensity = Math.max(0, L.userData.initialIntensity * (1.0 - tL * 1.6));
              // fade bolt line if present
              if (L.userData.line && L.userData.line.material) {
                const line = L.userData.line;
                const lm = line.material;
                lm.opacity = Math.max(0, 1.0 - tL * 1.4);
                if (tL >= 1.0 || lm.opacity <= 0.02) {
                  scene.remove(line);
                  if (line.geometry) line.geometry.dispose();
                  if (line.material) line.material.dispose();
                  L.userData.line = null;
                }
              }
              if (tL >= 1.0 || L.intensity <= 0.01) {
                // clean up any remaining line
                if (L.userData.line) {
                  const line = L.userData.line;
                  scene.remove(line);
                  if (line.geometry) line.geometry.dispose();
                  if (line.material) line.material.dispose();
                }
                scene.remove(L);
                if (L.dispose) L.dispose();
                c.userData._lightnings.splice(li, 1);
              }
            }
          }
        }
      }
      getPrecipitatingClouds() {
        return this.clouds.filter(c => c.userData.precipitating);
      }
    }

    class PrecipitationSystem {
      constructor() {
        this.droplets = [];
        this.poolSize = 390000;
        this.available = [];
        for (let i = 0; i < this.poolSize; i++) this.available.push(i);

        const quad = new THREE.PlaneGeometry(1, 1);
        this.instGeo = new THREE.InstancedBufferGeometry();
        this.instGeo.index = quad.index;
        this.instGeo.attributes.position = quad.attributes.position;
        this.instGeo.attributes.uv = quad.attributes.uv;

        const offsets = new Float32Array(this.poolSize * 3);
        const scales = new Float32Array(this.poolSize);
        const colors = new Float32Array(this.poolSize * 3);
        const visibility = new Float32Array(this.poolSize);

        this.instGeo.setAttribute('offset', new THREE.InstancedBufferAttribute(offsets, 3));
        this.instGeo.setAttribute('scale', new THREE.InstancedBufferAttribute(scales, 1));
        this.instGeo.setAttribute('iColor', new THREE.InstancedBufferAttribute(colors, 3));
        this.instGeo.setAttribute('vis', new THREE.InstancedBufferAttribute(visibility, 1));

        const mat = new THREE.ShaderMaterial({
          uniforms: {},
          vertexShader: `
            attribute vec3 offset;
            attribute float scale;
            attribute float vis;
            attribute vec3 iColor;
            varying vec3 vColor;
            varying float vVis;
            varying vec2 vUv;
            void main(){
              vColor = iColor;
              vVis = vis;
              vUv = uv;
              // stretch instanced quads vertically to create streak effect
              vec3 localPos = position * vec3(scale * 0.35, scale * 3.2, 1.0);
              vec3 pos = localPos + offset;
              vec4 mv = modelViewMatrix * vec4(pos, 1.0);
              gl_Position = projectionMatrix * mv;
            }`,
          fragmentShader: `
            varying vec3 vColor;
            varying float vVis;
            varying vec2 vUv;
            void main(){
              vec2 p = (vUv - 0.5) * vec2(0.5, 1.2);
              float dist = length(p * vec2(0.85, 1.0));
              float tip = smoothstep(0.9, 0.06, p.y + 0.6);
              float streak = smoothstep(0.98, 0.0, abs(p.x)) * smoothstep(1.0, -0.2, p.y);
              // sharpen streak core and reduce roundness to appear more like falling drops
              float alpha = smoothstep(0.9, 0.25, 1.0 - dist) * tip;
              alpha *= smoothstep(0.45, 0.08, dist);
              alpha = max(alpha, streak * 0.98);
              float highlight = smoothstep(0.0, 0.5, 1.0 - length((vUv - vec2(0.44,0.72)) * vec2(1.0,0.5)));
              vec3 color = mix(vColor * 0.9, vec3(1.0,1.0,1.0), highlight * 0.36);
              gl_FragColor = vec4(color, alpha * vVis);
              if (gl_FragColor.a < 0.01) discard;
            }`,
          transparent: true,
          depthWrite: false,
          blending: THREE.NormalBlending
        });

        this.instMesh = new THREE.Mesh(this.instGeo, mat);
        this.instMesh.frustumCulled = false;
        scene.add(this.instMesh);

        for (let i = 0; i < this.poolSize; i++) this.droplets.push(null);

        this.sheets = new Map();
        this.sheetMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.0, depthWrite: false });

        // prepare rain-shaft material factory for reuse
        this.rainShaftMaterialFactory = createRainShaftMaterial;
        this.activeShafts = new Map(); // cloud -> shaft mesh

        // Rain splash pool (flat quads on ground that fade)
        this.splashCapacity = 1024;
        this.splashAvailable = [];
        this.splashPool = [];
        this.splashGroup = new THREE.Group();
        scene.add(this.splashGroup);
        this.splashMat = new THREE.ShaderMaterial({
          uniforms: { uTime: { value: 0 } },
          vertexShader: `
            uniform float uTime;
            varying vec2 vUv;
            void main(){
              vUv = uv;
              vec4 mv = modelViewMatrix * vec4(position,1.0);
              gl_Position = projectionMatrix * mv;
            }
          `,
          fragmentShader: `
            varying vec2 vUv;
            void main(){
              vec2 p = vUv - 0.5;
              float d = length(p);
              float alpha = smoothstep(0.48, 0.18, d) * (1.0 - (mod(uTime*2.0,1.0)));
              vec3 col = vec3(0.55,0.6,0.9);
              gl_FragColor = vec4(col, alpha);
              if (gl_FragColor.a <= 0.01) discard;
            }
          `,
          transparent: true,
          depthWrite: false,
          blending: THREE.NormalBlending,
          side: THREE.DoubleSide
        });
        for (let i = 0; i < this.splashCapacity; i++) {
          this.splashAvailable.push(i);
          this.splashPool.push(null);
        }

        // Hail 3D pooled mesh system (small set of real spheres for visible hail impacts)
        this.hailCapacity = 512;
        this.hailAvailable = [];
        this.hailPool = [];
        this.hailGroup = new THREE.Group();
        scene.add(this.hailGroup);
        const hailGeom = new THREE.SphereGeometry(0.25, 8, 8);
        // hail visual material set to white
        this._hailMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6, metalness: 0.05 });
        for (let i = 0; i < this.hailCapacity; i++) {
          this.hailAvailable.push(i);
          this.hailPool.push(null);
        }
      }

      spawnSplash(x, z, size=0.6, life=0.8) {
        if (this.splashAvailable.length === 0) return;
        const id = this.splashAvailable.pop();
        let entry = this.splashPool[id];
        if (!entry) {
          const geo = new THREE.PlaneGeometry(1,1);
          const mesh = new THREE.Mesh(geo, this.splashMat.clone());
          mesh.rotation.x = -Math.PI/2;
          mesh.position.y = 0.605; // slightly above ground
          mesh.renderOrder = 999;
          this.splashGroup.add(mesh);
          entry = { mesh, life: 0, age: 0, size: 1 };
          this.splashPool[id] = entry;
        }
        entry.mesh.visible = true;
        entry.mesh.position.set(x, 0.605, z);
        entry.mesh.scale.setScalar(size);
        entry.age = 0;
        entry.life = life + Math.random() * 0.4;
        entry.size = size;
        entry.mesh.material.uniforms.uTime = { value: 0 };
        return id;
      }

      // spawn a real 3D hail chunk from the hail pool
      spawnHail(x, y, z, size = 0.4, initVelY = -8.0) {
        if (this.hailAvailable.length === 0) return;
        const id = this.hailAvailable.pop();
        let entry = this.hailPool[id];
        if (!entry) {
          // create mesh on demand
          const geo = new THREE.SphereGeometry(THREE.MathUtils.clamp(size * 1.0, 0.24, 1.2), 8, 8);
          // clone white hail material
          const mat = this._hailMat.clone();
          const mesh = new THREE.Mesh(geo, mat);
          mesh.castShadow = false;
          mesh.receiveShadow = false;
          this.hailGroup.add(mesh);
          entry = { mesh, pos: new THREE.Vector3(), velY: 0, age: 0, size };
          this.hailPool[id] = entry;
        }
        entry.mesh.visible = true;
        entry.size = size;
        entry.pos.set(x, y, z);
        entry.velY = initVelY;
        entry.age = 0;
        entry.mesh.position.copy(entry.pos);
        return id;
      }
      
      spawnDroplet(x, y, z, type, size, velY, color) {
        // hail removed: everything uses instanced droplets; splashes on ground handle impact visuals
        // allow hail to be represented by 3D hail objects for a visible effect in heavy storms
        if (type === 'hail') {
          // spawn as real 3D hail object; still create small visual instanced droplet optionally
          this.spawnHail(x, y, z, THREE.MathUtils.clamp(size * 1.0, 0.24, 1.2), velY || -9.0);
          // also produce a lighter instanced particle for mid-air streak appearance (optional)
          if (this.available.length === 0) return;
        }
        if (this.available.length === 0) return;
        // tweak defaults for raindrops to make them thinner and faster
        if (type === 'rain') {
          size = size * 0.75;
          velY = (velY !== undefined) ? velY : -6.0 - Math.random() * 3.0;
          color = { r: 0.22 + Math.random()*0.12, g: 0.45 + Math.random()*0.1, b: 0.82 + Math.random()*0.06 };
        } else if (type === 'sleet') {
          size = size * 0.9;
          velY = velY || -3.0;
          color = { r:0.5,g:0.6,b:0.85 };
        } else if (type === 'snow') {
          size = size * 1.8;
          velY = velY || -1.0;
          color = { r:1,g:1,b:1 };
        } else if (type === 'hail') {
          size = size || 0.6;
          velY = velY || -9.0;
          color = { r:1,g:1,b:1 };
        }
        const id = this.available.pop();
        this.droplets[id] = {
          pos: new THREE.Vector3(x, y, z),
          velY: velY,
          life: 6.0,
          type: type,
          size: size,
          color: color
        };
        const offs = this.instGeo.attributes.offset.array;
        const cols = this.instGeo.attributes.iColor.array;
        const sc = this.instGeo.attributes.scale.array;
        const vis = this.instGeo.attributes.vis.array;
        offs[id*3] = x; offs[id*3+1] = y; offs[id*3+2] = z;
        cols[id*3] = color.r; cols[id*3+1] = color.g; cols[id*3+2] = color.b;
        sc[id] = size;
        vis[id] = 1.0;
        this.instGeo.attributes.offset.needsUpdate = true;
        this.instGeo.attributes.iColor.needsUpdate = true;
        this.instGeo.attributes.scale.needsUpdate = true;
        this.instGeo.attributes.vis.needsUpdate = true;
      }

      update(precipClouds, windSystem, deltaTime) {
        // Defensive guards: ensure instanced attributes exist before operating on them
        const instAttrs = this.instGeo && this.instGeo.attributes;
        if (!instAttrs || !instAttrs.offset || !instAttrs.scale || !instAttrs.iColor || !instAttrs.vis) {
          return;
        }

        precipClouds.forEach(cloud => {
          const intensity = THREE.MathUtils.clamp(cloud.userData.precipitationIntensity || 0.05, 0.01, 1.0);
          const typeMult = (cloud.userData.type === 'supercell' ? 2.2 : (cloud.userData.type === 'cumulonimbus' ? 1.4 : (cloud.userData.type === 'stratus' ? 0.45 : 1.0)));
          const baseRate = 320 * Math.max(0.8, cloud.scale.x) * typeMult;
          const spawn = Math.floor(baseRate * intensity * deltaTime);
          const cloudPos = new THREE.Vector3();
          cloud.getWorldPosition(cloudPos);
          const emitter = cloud.userData.rainEmitter;
          for (let i = 0; i < spawn; i++) {
            const r = (Math.random() * 2 - 1) * (emitter ? emitter.radius : Math.max(2, cloud.scale.x * 1.2));
            const angle = Math.random() * Math.PI * 2;
            const x = (emitter ? emitter.position.x : cloudPos.x) + Math.cos(angle) * r;
            const z = (emitter ? emitter.position.z : cloudPos.z) + Math.sin(angle) * r;
            const top = cloudPos.y + (cloud.scale.y * 0.4);
            const y = THREE.MathUtils.lerp(top, Math.max(0.6, cloudPos.y - cloud.scale.y * 0.3), Math.random());
            let type = 'rain', size = 0.28, initVel = -4.0;
            // hail only from cumulonimbus or supercell, and respect user allowHail toggle
            const isSevere = (cloud.userData.type === 'supercell' || cloud.userData.type === 'cumulonimbus');
            const temp = state.controls.temperature;
            // hail spawn: very low base chance, moderately increased for severe storms and pyro-clouds
            let hailChance = 0.001; // tiny base chance to avoid ubiquitous hail
            if (isSevere) hailChance = 0.007;
            if (isSevere && cloud.userData && cloud.userData.pyro) hailChance = 0.02; // stronger for volcanic+severe
            // respect global hail toggle
            if (!state.controls.allowHail) hailChance = 0.0;
            if (Math.random() < hailChance) {
              type = 'hail';
              size = 0.36 + Math.random() * 0.8;
              initVel = -8.0;
            } else if (temp < 0) { 
              // snow falls much slower: keep gentle initial velocity and will be slowed in update
              type = 'snow'; size = 1.4; initVel = -1.0; 
            } else if (temp < 2) { 
              type = 'sleet'; size = 0.9; initVel = -2.0; 
            }
            if (cloud.userData.type === 'stratus') { size *= 0.6; initVel *= 0.6; }
            // make rain/sleet colors bluish instead of greenish
            // hail should appear white
            const color = (type === 'snow' || type === 'hail') ? { r:1,g:1,b:1 } : { r:0.25 + Math.random()*0.15, g:0.45 + Math.random()*0.15, b:0.8 + Math.random()*0.15 };
            this.spawnDroplet(x, y, z, type, size, initVel, color);
          }

          // --- Rain shaft: create or update a vertical shaft mesh for this cloud's emitter ---
          if (emitter) {
            // reuse existing shaft for this cloud if present (now as a 3D cylinder)
            let shaft = this.activeShafts.get(cloud);
            const shaftIntensity = THREE.MathUtils.clamp((cloud.userData.precipitationIntensity || 0.2) * (emitter.opacity || 1.0), 0.0, 1.0);
            // compute top of emitter (approx top where droplets originate)
            const emitterTopY = emitter.position.y + emitter.height * 0.5;
            const groundY = 0.605;
            // cylinder height should extend from emitterTopY down to ground (minimum tiny height)
            const shaftHeight = Math.max(0.8, emitterTopY - groundY);
            const shaftRadius = Math.max(0.5, emitter.radius * 0.9);

            if (!shaft) {
              // create a tapered shaft by using a cylinder with smaller top radius (cone-like taper)
              const geom = new THREE.CylinderGeometry(shaftRadius * 0.26, shaftRadius, shaftHeight, 18, 1, true);
              const mat = this.rainShaftMaterialFactory();
              shaft = new THREE.Mesh(geom, mat);
              shaft.userData.isShaft = true;
              shaft.renderOrder = 998;
              scene.add(shaft);
              this.activeShafts.set(cloud, shaft);
            } else {
              // replace geometry to match updated radius/height (dispose old)
              if (shaft.geometry) shaft.geometry.dispose();
              // keep tapered profile on updates as well
              shaft.geometry = new THREE.CylinderGeometry(shaftRadius * 0.26, shaftRadius, shaftHeight, 18, 1, true);
            }

            // position the cylinder so its top aligns roughly with emitterTopY and bottom meets groundY
            shaft.position.set(emitter.position.x, groundY + shaftHeight * 0.5, emitter.position.z);
            // orient cylinder so its axis is vertical (default) but allow a stronger slant by rotating around X/Z based on mid-level wind
            const midLevelAlt = Math.max(1.0, groundY + shaftHeight * 0.5);
            const windAtMid = windSystem.getWindAtAltitude(midLevelAlt);
            // small slant angle derived from wind vector, slightly stronger to show tilt
            const slantX = THREE.MathUtils.clamp(-windAtMid.y * 0.14, -0.5, 0.5);
            const slantZ = THREE.MathUtils.clamp(windAtMid.x * 0.14, -0.5, 0.5);
            shaft.rotation.set(slantX, 0, slantZ);

            // estimate virga strength: more likely when humidity is low and intensity is modest
            const envHumidity = state.controls.humidity || 0;
            const dryness = THREE.MathUtils.clamp((60 - envHumidity) / 30, 0.0, 1.0);
            const virgaStrength = THREE.MathUtils.clamp(dryness * (1.0 - shaftIntensity) * 1.4, 0.0, 1.0);

            // update shader uniforms to animate streaks along the cylinder surface
            if (shaft.material && shaft.material.uniforms) {
              shaft.material.uniforms.uTime.value = Date.now() * 0.001;
              shaft.material.uniforms.uIntensity.value = 0.35 + shaftIntensity * 1.6;
              shaft.material.uniforms.uColor.value = new THREE.Color(0x4aa0ff);
              shaft.material.uniforms.uWind.value = new THREE.Vector2(
                windAtMid.x * state.controls.windSpeed * 3.0,
                windAtMid.y * state.controls.windSpeed * 3.0
              );
              shaft.material.uniforms.uVirga.value = virgaStrength;
            }
            shaft.visible = shaftIntensity > 0.03;
          }
        });

        // cleanup shafts for clouds that are no longer precipitating or removed
        this.activeShafts.forEach((shaft, cloudKey) => {
          // if cloudKey is no longer in precipClouds by reference or cloud was removed, remove shaft
          const still = precipClouds.indexOf(cloudKey) !== -1 && cloudKey.userData && cloudKey.userData.rainEmitter;
          if (!still) {
            if (shaft) {
              scene.remove(shaft);
              if (shaft.geometry) shaft.geometry.dispose();
              if (shaft.material) shaft.material.dispose();
            }
            this.activeShafts.delete(cloudKey);
          }
        });

        let cooling = 0;
        const offs = instAttrs.offset.array;
        const cols = instAttrs.iColor.array;
        const sc = instAttrs.scale.array;
        const vis = instAttrs.vis.array;
        for (let i = 0; i < this.poolSize; i++) {
          const d = this.droplets[i];
          if (!d) continue;
          // gravity & drag: slow snow fall 4x, give hail stronger gravity
          let gravityScale = 1.0;
          if (d.type === 'snow') gravityScale = 0.25; // snow falls 4x slower
          if (d.type === 'hail') gravityScale = 2.2;  // hail heavier, falls faster in instanced streaks
          // reduce fall acceleration by ~15% for a gentler descent
          d.velY += -1.8 * 0.08 * 0.85 * deltaTime * gravityScale;
          d.pos.y += d.velY * deltaTime;
          const wind = windSystem.getWindAtAltitude(d.pos.y);
          const windMult = (d.type === 'snow' ? 0.45 : (d.type === 'hail' ? 0.6 : 1.0));
          d.pos.x += wind.x * windMult * deltaTime * 8.0;
          d.pos.z += wind.y * windMult * deltaTime * 8.0;
          offs[i*3] = d.pos.x; offs[i*3+1] = d.pos.y; offs[i*3+2] = d.pos.z;
          cols[i*3] = d.color.r; cols[i*3+1] = d.color.g; cols[i*3+2] = d.color.b;
          sc[i] = d.size;
          vis[i] = 1.0;

          if (d.pos.y <= 0.6) {
            let coolFactor;
            if (d.type === 'snow') coolFactor = 0.02;
            else if (d.type === 'sleet') coolFactor = 0.015;
            else coolFactor = 0.008; // Rain & others
            const cool = coolFactor * (d.size);
            cooling += cool;

            // spawn a splash for rain / sleet at the ground impact
            const splashSize = THREE.MathUtils.clamp(d.size * (d.type === 'sleet' ? 1.6 : 1.0) * (0.8 + Math.random() * 0.8), 0.2, 1.6);
            this.spawnSplash(d.pos.x, d.pos.z, splashSize, 0.4 + Math.random() * 0.6);

            // recycle droplet
            this.droplets[i] = null;
            this.available.push(i);
            vis[i] = 0.0;
          }
        }

        if (cooling > 0) {
          const applied = Math.min(0.6, cooling * 60.0 * (state.controls.simulationSpeed || 1.0));
          state.controls.temperature = Math.max(-60, state.controls.temperature - applied * 0.06);
        }

        precipClouds.forEach(cloud => {
          const anvil = cloud.userData.anvilEmitter;
          const anvilInt = THREE.MathUtils.clamp(cloud.userData.anvilPrecipIntensity || 0, 0, 1);
          if (!anvil || anvilInt <= 0.01) return;
          const cloudPos = new THREE.Vector3();
          cloud.getWorldPosition(cloudPos);
          const typeMult = (cloud.userData.type === 'supercell' ? 2.6 : (cloud.userData.type === 'cumulonimbus' ? 1.6 : 1.0));
          const baseRate = 1000 * Math.max(0.9, cloud.scale.x) * typeMult;
          const spawn = Math.floor(baseRate * anvilInt * deltaTime);
          for (let i = 0; i < spawn; i++) {
            const r = (Math.random() * 2 - 1) * anvil.radius * 0.6;
            const angle = Math.random() * Math.PI * 2;
            const x = anvil.position.x + Math.cos(angle) * r;
            const z = anvil.position.z + Math.sin(angle) * r;
            const top = anvil.position.y + 0.5;
            const y = THREE.MathUtils.lerp(top, Math.max(0.6, anvil.position.y - anvil.height * 0.5), Math.random());
            let type = 'rain', size = 0.32, initVel = -5.0;
            const isSevere = cloud.userData.type === 'supercell' || cloud.userData.type === 'cumulonimbus';
            const temp = state.controls.temperature;
            
            if (temp < 0) { 
              type = 'snow'; size = 1.6; initVel = -1.2; 
            }
            // anvil precipitation color to blueish too
            const color = (type === 'snow') ? { r:1,g:1,b:1 } : { r:0.25 + Math.random()*0.15, g:0.45 + Math.random()*0.15, b:0.8 + Math.random()*0.15 };
            this.spawnDroplet(x, y, z, type, size, initVel, color);
          }
        });

        instAttrs.offset.needsUpdate = true;
        instAttrs.iColor.needsUpdate = true;
        instAttrs.scale.needsUpdate = true;
        instAttrs.vis.needsUpdate = true;

        // Update active splash pieces: fade and recycle
        for (let si = 0; si < this.splashPool.length; si++) {
          const s = this.splashPool[si];
          if (!s) continue;
          if (!s.mesh || !s.mesh.visible) continue;
          s.age += deltaTime;
          const u = s.age / s.life;
          // scale slightly outward and fade
          if (s.mesh) {
            s.mesh.scale.setScalar(THREE.MathUtils.lerp(s.size, s.size * 1.6, u));
            const mat = s.mesh.material;
            if (mat && mat.uniforms && mat.uniforms.uTime) mat.uniforms.uTime.value = u;
            if (u >= 1.0) {
              s.mesh.visible = false;
              this.splashAvailable.push(si);
            }
          }
        }

        // Update hail 3D pool: move real hail meshes and spawn splashes on impact
        for (let hi = 0; hi < this.hailPool.length; hi++) {
          const h = this.hailPool[hi];
          if (!h) continue;
          if (!h.mesh || !h.mesh.visible) continue;
          h.age += deltaTime;
          // stronger gravity for hail (reduced ~15% for slower impacts)
          h.velY += -9.8 * deltaTime * 1.1 * 0.85;
          h.pos.y += h.velY * deltaTime;
          // light lateral drift
          const wind = windSystem.getWindAtAltitude(h.pos.y || 2.0);
          h.pos.x += wind.x * 0.6 * deltaTime * 6.0;
          h.pos.z += wind.y * 0.6 * deltaTime * 6.0;
          h.mesh.position.copy(h.pos);
          if (h.pos.y <= 0.62) {
            // impact: small bounce effect then hide
            this.spawnSplash(h.pos.x, h.pos.z, THREE.MathUtils.clamp(h.size * 0.8, 0.18, 1.0), 0.28);
            h.mesh.visible = false;
            h.age = 0;
            // recycle
            this.hailAvailable.push(hi);
          }
        }
      }

      reset() {
        this.available.length = 0;
        for (let i = 0; i < this.poolSize; i++) {
          this.available.push(i);
          this.droplets[i] = null;
          this.instGeo.attributes.vis.array[i] = 0.0;
        }
        this.instGeo.attributes.vis.needsUpdate = true;
        this.sheets.forEach(m => {
          scene.remove(m);
          if (m.geometry) m.geometry.dispose();
        });
        this.sheets.clear();

        // clear rain shafts
        this.activeShafts.forEach(shaft => {
          scene.remove(shaft);
          if (shaft.geometry) shaft.geometry.dispose();
          if (shaft.material) shaft.material.dispose();
        });
        this.activeShafts.clear();

        // clear splashes
        for (let i = 0; i < this.splashPool.length; i++) {
          const s = this.splashPool[i];
          if (!s) continue;
          if (s.mesh) { s.mesh.visible = false; }
          this.splashAvailable.push(i);
        }
        // clear hail pool
        for (let i = 0; i < this.hailPool.length; i++) {
          const h = this.hailPool[i];
          if (!h) continue;
          if (h.mesh) { h.mesh.visible = false; }
          this.hailAvailable.push(i);
        }
      }
    }

    // TornadoSystem remains but optional; unchanged from before (kept for later)
    class TornadoSystem {
      constructor() {
        this.activeTornadoes = [];
        this.spawnCooldown = 0;
        this.maxTornadoes = 3;
        this.meshRoot = new THREE.Group();
        scene.add(this.meshRoot);
      }
      createTornadoForCloud(cloud) {
        const funnel = new THREE.Group();
        // pure particle funnel: vertical column of swirling debris
        const pMax = 200;
        const pPos = new Float32Array(pMax * 3);
        const pCol = new Float32Array(pMax * 3);
        const pSize = new Float32Array(pMax);
        const pData = [];
        for (let i = 0; i < pMax; i++) {
          const a = Math.random() * Math.PI * 2;
          const r = Math.random() * 2.5;
          pPos[i * 3] = Math.cos(a) * r;
          pPos[i * 3 + 1] = Math.random() * 6;
          pPos[i * 3 + 2] = Math.sin(a) * r;
          const g = 0.2 + Math.random() * 0.2;
          pCol[i * 3] = 0.15 + Math.random() * 0.15;
          pCol[i * 3 + 1] = g;
          pCol[i * 3 + 2] = 0.15;
          pSize[i] = 8 + Math.random() * 10;
          pData.push({ angle: a, radius: r, y: pPos[i * 3 + 1], speed: 0.8 + Math.random() * 1.2 });
        }
        const pg = new THREE.BufferGeometry();
        pg.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        pg.setAttribute('color', new THREE.BufferAttribute(pCol, 3));
        pg.setAttribute('size', new THREE.BufferAttribute(pSize, 1));
        const pmat = new THREE.ShaderMaterial({
          uniforms: {},
          vertexShader: `
            attribute float size;
            attribute vec3 color;
            varying vec3 vColor;
            void main(){
              vColor = color;
              vec4 mv = modelViewMatrix * vec4(position,1.0);
              gl_PointSize = size * (420.0 / max(1.0, -mv.z));
              gl_Position = projectionMatrix * mv;
            }
          `,
          fragmentShader: `
            varying vec3 vColor;
            void main(){
              vec2 c = gl_PointCoord - vec2(0.5);
              float d = length(c);
              if(d > 0.95) discard;
              float a = 1.0 - smoothstep(0.02,0.95,d);
              gl_FragColor = vec4(vColor, a * 1.6);
            }
          `,
          transparent: true,
          blending: THREE.NormalBlending,
          depthWrite: false
        });
        const pPoints = new THREE.Points(pg, pmat);
        pPoints.userData._particles = pData;
        pPoints.userData._geoRef = pg;
        funnel.add(pPoints);

        funnel.userData = {
          parentCloud: cloud,
          age: 0,
          life: 80 + Math.random() * 120,
          intensity: 0.6 + Math.random() * 0.9,
          rotationSpeed: 0.6 + Math.random() * 1.2,
          verticalOffset: 0,
          orbitAngle: Math.random() * Math.PI * 2,
          orbitRadius: 4 + Math.random() * 4
        };

        this.meshRoot.add(funnel);
        // mark cloud as having a tornado
        cloud.userData.hasTornado = true;
        this.activeTornadoes.push(funnel);
        return funnel;
      }
      update(supercellClouds, deltaTime) {
        this.spawnCooldown = Math.max(0, this.spawnCooldown - deltaTime);
        // spawn only on supercells, and only if they are strong and precipitating
        if (this.activeTornadoes.length < this.maxTornadoes && this.spawnCooldown <= 0) {
          for (let i = 0; i < supercellClouds.length; i++) {
            const c = supercellClouds[i];
            if (c.userData.hasTornado) continue;
            const intensity = c.userData.precipitationIntensity || 0;
            if (c.userData.precipitating && intensity > 0.6 && Math.random() < 0.15 * deltaTime) {
              this.createTornadoForCloud(c);
              this.spawnCooldown = 25 + Math.random() * 35;
              break;
            }
          }
        }

        for (let i = this.activeTornadoes.length - 1; i >= 0; i--) {
          const t = this.activeTornadoes[i];
          const ud = t.userData;
          ud.age += deltaTime;
          if (!ud.parentCloud || ud.age > ud.life || ud.parentCloud.userData.age > ud.parentCloud.userData.maxAge) {
            if (ud.parentCloud) ud.parentCloud.userData.hasTornado = false;
            // fade-out: simply remove after extra time
            if (ud.age > ud.life + 4) {
              if (ud.parentCloud) ud.parentCloud.userData.hasTornado = false;
              this.meshRoot.remove(t);
              t.traverse(node => {
                if (node.geometry) node.geometry.dispose();
                if (node.material) node.material.dispose();
              });
              this.activeTornadoes.splice(i, 1);
            }
            continue;
          }

          const cloudPos = new THREE.Vector3();
          ud.parentCloud.getWorldPosition(cloudPos);
          // orbit around supercell base
          ud.orbitAngle += (0.3 + ud.intensity * 0.3) * deltaTime;
          const orbitR = ud.orbitRadius * (0.8 + Math.sin(ud.age * 0.3) * 0.2);
          const cloudBaseY = cloudPos.y - (ud.parentCloud.scale.y * 0.9);
          const targetPos = new THREE.Vector3(
            cloudPos.x + Math.cos(ud.orbitAngle) * orbitR,
            Math.max(0.2, cloudBaseY - 0.6),
            cloudPos.z + Math.sin(ud.orbitAngle) * orbitR
          );
          t.position.lerp(targetPos, 0.25);

          // spin the whole particle column
          t.rotation.y += ud.rotationSpeed * deltaTime * (0.8 + ud.intensity * 1.2);

          const wobble = Math.sin(ud.age * 2.0) * 0.3 * ud.intensity;
          t.position.y = Math.max(0.2, targetPos.y + wobble);

          const scaleBase = 0.6 + ud.intensity * 1.8;
          t.scale.set(scaleBase, scaleBase, scaleBase);

          const points = t.children.find(ch => ch.type === 'Points');
          if (points) {
            const posAttr = points.geometry.attributes.position;
            const pdata = points.userData._particles;
            for (let pi = 0; pi < pdata.length; pi++) {
              const d = pdata[pi];
              d.angle += (0.8 + ud.intensity * 2.0) * deltaTime;
              d.radius += (0.02 + ud.intensity * 0.06) * deltaTime;
              d.y -= (0.18 + ud.intensity * 0.4) * deltaTime;
              if (d.y < 0.1) {
                d.y = 5.5 + Math.random() * 1.6;
                d.radius = Math.random() * 2.5;
              }
              posAttr.array[pi * 3] = Math.cos(d.angle) * d.radius;
              posAttr.array[pi * 3 + 1] = d.y;
              posAttr.array[pi * 3 + 2] = Math.sin(d.angle) * d.radius;
            }
            posAttr.needsUpdate = true;
          }

          const distToCamera = t.position.distanceTo(camera.position);
          if (distToCamera < 30 && ud.intensity > 0.9) {
            const mag = (30 - distToCamera) / 30 * ud.intensity * 0.9;
            camera.position.x += (Math.random() - 0.5) * mag;
            camera.position.y += (Math.random() - 0.5) * (mag * 0.5);
          }
        }
      }
    }

    class RadarSystem {
      constructor() {
        this.canvas = document.getElementById('radarCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.sweepAngle = 0;
        // match radar range to expanded cloud territory
        this.range = 1200;
      }
      update(clouds, tornadoes, cameraPos) {
        const ctx = this.ctx, w = this.canvas.width, h = this.canvas.height;
        const cx = w / 2, cy = h / 2, r = w / 2 - 10;
        ctx.fillStyle = 'rgba(0, 20, 0, 0.3)';
        ctx.fillRect(0, 0, w, h);
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
        ctx.lineWidth = 1;
        for (let i = 1; i <= 3; i++) {
          ctx.beginPath();
          ctx.arc(cx, cy, (r / 3) * i, 0, Math.PI * 2);
          ctx.stroke();
        }
        // subtle crosshair
        ctx.beginPath();
        ctx.moveTo(cx - 4, cy);
        ctx.lineTo(cx + 4, cy);
        ctx.moveTo(cx, cy - 4);
        ctx.lineTo(cx, cy + 4);
        ctx.stroke();
        
        clouds.forEach(c => {
          const dx = c.position.x - cameraPos.x, dz = c.position.z - cameraPos.z;
          const dist = Math.sqrt(dx * dx + dz * dz);
          if (dist < this.range) {
            const a = Math.atan2(dz, dx);
            const nd = (dist / this.range) * r;
            const x = cx + Math.cos(a) * nd, y = cy + Math.sin(a) * nd;
            // color by precipitation intensity (green->yellow->orange->red)
            const intensity = THREE.MathUtils.clamp(c.userData.precipitationIntensity || 0, 0, 1);
            let color = 'rgba(0,255,0,0.6)'; let size = 3;
            if (intensity > 0.75) { color = 'rgba(255,0,0,0.95)'; size = 6; }
            else if (intensity > 0.45) { color = 'rgba(255,140,0,0.9)'; size = 5; }
            else if (intensity > 0.15) { color = 'rgba(255,220,0,0.8)'; size = 4; }
            // elevate icons for severe types
            if (c.userData.type === 'supercell' || c.userData.type === 'derecho') { color = 'rgba(200,0,200,0.95)'; size = 7; }
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
          }
        });
        
        this.sweepAngle += 0.05;
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + Math.cos(this.sweepAngle) * r, cy + Math.sin(this.sweepAngle) * r);
        ctx.stroke();
        // show tornado count badge
        const tornadoCount = clouds.reduce((acc, c) => acc + (c.userData.hasTornado ? 1 : 0), 0);
        ctx.fillStyle = 'rgba(255,0,255,0.9)';
        ctx.beginPath();
        ctx.arc(w - 28, 20, 14, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(String(tornadoCount), w - 28, 20);
      }
    }

    class CameraController {
      constructor(camera) {
        this.camera = camera;
        this.moveSpeed = 0.5;
        this.yaw = 0;
        this.pitch = 0;
        this.moveForward = this.moveBackward = this.moveLeft = this.moveRight = this.moveUp = this.moveDown = false;
        this.isDragging = false;
        this.lastMousex = this.lastMouseY = 0;
        this.shake = new THREE.Vector3(); // accumulated shake offsets
        this.shakeVel = new THREE.Vector3();
        this.setupControls();
      }
      setupControls() {
        document.addEventListener('keydown', (e) => {
          const k = e.key.toLowerCase();
          if (k === 'w' || k === 'arrowup') this.moveForward = true;
          if (k === 's' || k === 'arrowdown') this.moveBackward = true;
          if (k === 'a' || k === 'arrowleft') this.moveLeft = true;
          if (k === 'd' || k === 'arrowright') this.moveRight = true;
          if (k === 'q') this.moveDown = true;
          if (k === 'e') this.moveUp = true;
        });
        document.addEventListener('keyup', (e) => {
          const k = e.key.toLowerCase();
          if (k === 'w' || k === 'arrowup') this.moveForward = false;
          if (k === 's' || k === 'arrowdown') this.moveBackward = false;
          if (k === 'a' || k === 'arrowleft') this.moveLeft = false;
          if (k === 'd' || k === 'arrowright') this.moveRight = false;
          if (k === 'q') this.moveDown = false;
          if (k === 'e') this.moveUp = false;
        });
        document.addEventListener('mousedown', (e) => {
          if (e.button === 0 && e.target === renderer.domElement) {
            this.isDragging = true;
            // store starting positions consistently
            this.lastMouseX = e.clientX;
            this.lastMouseY = e.clientY;
            e.preventDefault();
          }
        });
        document.addEventListener('mouseup', () => this.isDragging = false);
        document.addEventListener('mousemove', (e) => {
          if (this.isDragging) {
            // reduced sensitivity for desktop mouse
            this.yaw -= (e.clientX - this.lastMouseX) * 0.0015;
            this.pitch -= (e.clientY - this.lastMouseY) * 0.0015;
            this.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch));
            this.lastMouseX = e.clientX;
            this.lastMouseY = e.clientY;
            e.preventDefault();
          }
        });
        document.addEventListener('touchstart', (e) => {
          if (e.touches.length === 1 && e.target === renderer.domElement) {
            this.isDragging = true;
            this.lastMouseX = e.touches[0].clientX;
            this.lastMouseY = e.touches[0].clientY;
            e.preventDefault();
          }
        }, { passive: false });
        document.addEventListener('touchmove', (e) => {
          if (this.isDragging && e.touches.length === 1) {
            // slightly reduced sensitivity for touch drags
            this.yaw -= (e.touches[0].clientX - this.lastMouseX) * 0.0025;
            this.pitch -= (e.touches[0].clientY - this.lastMouseY) * 0.0025;
            this.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch));
            this.lastMouseX = e.touches[0].clientX;
            this.lastMouseY = e.touches[0].clientY;
            e.preventDefault();
          }
        }, { passive: false });
        document.addEventListener('touchend', () => this.isDragging = false);
      }
      // external call to add a temporary camera impulse (dx, dy, durationScale)
      applyShake(dx, dy, strength = 1.0) {
        // convert to local shake vector; z not used for screen-space shake
        this.shakeVel.x += dx * strength;
        this.shakeVel.y += dy * strength;
      }
      update(deltaTime = 0.016) {
        const forward = new THREE.Vector3(Math.sin(this.yaw), 0, Math.cos(this.yaw));
        const right = new THREE.Vector3(Math.cos(this.yaw), 0, -Math.sin(this.yaw));
        if (this.moveForward) this.camera.position.addScaledVector(forward, this.moveSpeed);
        if (this.moveBackward) this.camera.position.addScaledVector(forward, -this.moveSpeed);
        if (this.moveRight) this.camera.position.addScaledVector(right, this.moveSpeed);
        if (this.moveLeft) this.camera.position.addScaledVector(right, -this.moveSpeed);
        if (this.moveUp && this.camera.position.y < 5) this.camera.position.y += this.moveSpeed * 0.5;
        if (this.moveDown && this.camera.position.y > 0.5) this.camera.position.y -= this.moveSpeed * 0.5;
        this.camera.position.y = Math.max(0.5, Math.min(5, this.camera.position.y));

        // update shake (simple critically-damped spring)
        const damp = 8.0;
        this.shakeVel.multiplyScalar(Math.exp(-damp * deltaTime));
        this.shake.addScaledVector(this.shakeVel, deltaTime * 60.0); // integrate with frame scaling
        // decay shake over time
        this.shake.multiplyScalar(Math.max(0, 1 - deltaTime * 3.0));
        // apply shake offsets
        this.camera.position.x += this.shake.x;
        this.camera.position.y += this.shake.y;

        const lookDir = new THREE.Vector3(
          Math.sin(this.yaw) * Math.cos(this.pitch),
          Math.sin(this.pitch),
          Math.cos(this.yaw) * Math.cos(this.pitch)
        );
        const lookTarget = new THREE.Vector3().addVectors(this.camera.position, lookDir);
        this.camera.lookAt(lookTarget);
      }
    }

    // Simple Volcano emitter that can bias nearby clouds into pyrocumulus formations
    class Volcano {
      // size: 0.5 (small) .. 1.8 (large) controls visual scale and influence radius
      constructor(x = -50, z = 20, size = 1.0) {
        this.position = new THREE.Vector3(x, 0, z);
        this.active = true;
        this.size = size;
        // visual: cone scaled by size
        const geom = new THREE.ConeGeometry(4 * size, 6 * size, 16);
        const mat = new THREE.MeshStandardMaterial({ color: 0x44302a, roughness: 1.0 });
        this.mesh = new THREE.Mesh(geom, mat);
        // lift mesh proportionally to size so base remains on ground
        this.mesh.position.set(x, 3 * size, z);
        this.mesh.scale.set(1, 1, 1);
        this.mesh.rotation.y = Math.random() * Math.PI * 2;
        scene.add(this.mesh);
        // ember sprite scaled by size
        const spriteTex = createHaloTexture(128, 'rgba(255,140,60,1.0)');
        const spMat = new THREE.SpriteMaterial({ map: spriteTex, transparent: true, opacity: 0.0, depthTest: false, blending: THREE.AdditiveBlending });
        this.ember = new THREE.Sprite(spMat);
        this.ember.scale.set(8 * size, 8 * size, 1);
        this.ember.position.set(x, 6 * size, z);
        scene.add(this.ember);
        // influence radius used when deciding pyro-cloud placement
        // scale influence strongly with size so big volcanoes produce many plumes and bias pyro-cloud formation
        this.influenceRadius = 160 + (size * 420); // larger volcano influences wider area
      }
      update(dt) {
        if (!this.active) { this.ember.material.opacity = Math.max(0, this.ember.material.opacity - dt * 0.8); return; }
        // pulse ember visibility
        const op = 0.25 + Math.abs(Math.sin(Date.now()*0.0016)) * 0.35;
        this.ember.material.opacity += (op - this.ember.material.opacity) * Math.min(1, dt * 4.0);
      }
    }

    const windSystem = new WindSystem();
    const cloudSystem = new CloudSystem();
    // Volcano spawning system: higher chance to spawn 1-3 volcanoes distributed around scene
    const volcanoes = [];
    function spawnVolcanoes() {
      // respect control toggle
      if (!state.controls.spawnVolcanoes) return;
      // 90% chance to have volcano activity at start; spawn 1-3 volcanoes
      if (Math.random() < 0.9) {
        const count = 1 + Math.floor(Math.random() * 3);
        for (let i = 0; i < count; i++) {
          const x = (Math.random() - 0.5) * 320; // spread across area
          const z = (Math.random() - 0.5) * 320;
          // widen size range so some volcanoes can be much larger and produce many plumes
          const size = 0.6 + Math.random() * 2.4; // 0.6 .. 3.0
          const v = new Volcano(x, z, size);
          // slight randomize active flag to allow dormant volcanoes occasionally
          v.active = Math.random() < 0.92;
          volcanoes.push(v);
        }
      } else {
        // small chance of single quiet volcano with modest size
        volcanoes.push(new Volcano(-40, 28, 0.9));
      }
    }
    spawnVolcanoes();
    const radarSystem = new RadarSystem();
    const cameraController = new CameraController(camera);
    const precipitationSystem = new PrecipitationSystem();
    const treeSystem = new TreeSystem();
    const tornadoSystem = new TornadoSystem();
    const vignetteEl = document.getElementById('vignette');
    // wire up cloud toggles UI -> cloudSystem.allowedTypes
    (function(){
      const panel = document.getElementById('cloudTogglePanel');
      if (!panel) return;
      panel.querySelectorAll('input[type="checkbox"]').forEach(cb => {
        const key = cb.getAttribute('data-cloud');
        cb.addEventListener('change', () => {
          if (cloudSystem && cloudSystem.allowedTypes && key) cloudSystem.allowedTypes[key] = cb.checked;
        });
        // initialize allowedTypes from DOM if present
        if (cloudSystem && cloudSystem.allowedTypes && key) cloudSystem.allowedTypes[key] = cb.checked;
      });
    })();

    // wire up volcano spawn toggle
    (function(){
      const el = document.getElementById('spawnVolcanoToggle');
      if (!el) return;
      el.checked = !!state.controls.spawnVolcanoes;
      el.addEventListener('change', (e) => {
        state.controls.spawnVolcanoes = !!e.target.checked;
      });
    })();

    // wire up shadows toggle
    (function(){
      const sh = document.getElementById('toggleShadows');
      if (!sh) return;
      sh.checked = !!state.controls.enableShadows;
      sh.addEventListener('change', (e) => {
        state.controls.enableShadows = !!e.target.checked;
        // enable/disable renderer shadowMap; keep simple toggle (some geometries may not cast/receive)
        renderer.shadowMap.enabled = state.controls.enableShadows;
      });
    })();

    // wire up hail toggle
    (function(){
      const h = document.getElementById('toggleHail');
      if (!h) return;
      h.checked = !!state.controls.allowHail;
      h.addEventListener('change', (e) => {
        state.controls.allowHail = !!e.target.checked;
      });
    })();

    // update volcano each frame
    function updateVolcano(dt) {
      for (let i = 0; i < volcanoes.length; i++) {
        const v = volcanoes[i];
        if (v) v.update(dt);
      }
    }

    let lastTime = Date.now();
    // FPS tracking
    let fpsAcc = 0, fpsLastTime = Date.now(), fpsFrames = 0;
    function animate() {
      requestAnimationFrame(animate);
      const now = Date.now();
      const deltaTime = ((now - lastTime) / 1000) * state.controls.simulationSpeed;
      lastTime = now;

      // update FPS every 0.5s (smoothed)
      fpsFrames++;
      const fpsNow = Date.now();
      if (fpsNow - fpsLastTime >= 500) {
        const fps = Math.round((fpsFrames * 1000) / (fpsNow - fpsLastTime));
        const fpsEl = document.getElementById('fps');
        if (fpsEl) fpsEl.textContent = String(fps);
        fpsFrames = 0;
        fpsLastTime = fpsNow;
      }

      cameraController.update();

      if (!state.paused) {
        windSystem.baseSpeed = 0.03 * state.controls.windSpeed;
        windSystem.update(deltaTime);
        updateVolcano(deltaTime);
        cloudSystem.humidity = state.controls.humidity;
        cloudSystem.temperature = state.controls.temperature;
        cloudSystem.evaporationRate = state.controls.evaporationRate;
        cloudSystem.update(deltaTime, windSystem);

        const precipClouds = cloudSystem.getPrecipitatingClouds();
        // update tornadoes only on supercells
        const supercellClouds = cloudSystem.clouds.filter(c => c.userData.type === 'supercell');
        tornadoSystem.update(supercellClouds, deltaTime);
        radarSystem.update(cloudSystem.clouds, tornadoSystem.activeTornadoes, camera.position);
        // Vignette: only show when a large cloud is overhead above camera
        (function(){
          let maxOpacity = 0;
          for (let i = 0; i < cloudSystem.clouds.length; i++) {
            const c = cloudSystem.clouds[i];
            // consider clouds that are above the camera and fairly large/close
            const vertGap = c.position.y - camera.position.y;
            const horiz = Math.hypot(c.position.x - camera.position.x, c.position.z - camera.position.z);
            const sizeFactor = Math.max(c.scale.x, c.scale.y);
            if (vertGap > 2 && horiz < 60 && sizeFactor > 1.6 && c.userData.precipitating) {
              // opacity scaled by how close and how large the cloud is
              const closeness = THREE.MathUtils.clamp(1 - horiz / 60, 0, 1);
              const op = THREE.MathUtils.clamp(0.15 + (sizeFactor - 1.6) * 0.12 + closeness * 0.45, 0, 0.9);
              maxOpacity = Math.max(maxOpacity, op);
            }
          }
          if (vignetteEl) vignetteEl.style.opacity = String(maxOpacity);
        })();

        // Update cirrus halo visibility when user is looking at them
        (function(){
          // derive camera forward vector
          const camDir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
          for (let i = 0; i < cloudSystem.clouds.length; i++) {
            const c = cloudSystem.clouds[i];
            if (!c.userData || !c.userData.halo) continue;
            const halo = c.userData.halo;
            // compute direction from camera to cloud
            const toCloud = new THREE.Vector3().subVectors(c.position, camera.position).normalize();
            const facing = camDir.dot(toCloud); // 1 = looking directly at cloud
            // visible only when looking nearly towards it and it's reasonably large/high
            const visible = facing > 0.72 && c.position.y > camera.position.y + 8;
            // fade opacity smoothly by facing and proximity
            const base = THREE.MathUtils.clamp((facing - 0.72) / (1 - 0.72), 0, 1);
            const dist = camera.position.distanceTo(c.position);
            const distFactor = THREE.MathUtils.clamp(1 - (dist / 220), 0, 1);
            const targetOp = visible ? Math.min(0.85, 0.35 + base * 0.1 * distFactor) : 0.0;
            halo.material.opacity += (targetOp - halo.material.opacity) * Math.min(1, deltaTime * 3.0);
            // scale halo slightly with distance and facing
            const scaleBase = THREE.MathUtils.lerp(6, 26, THREE.MathUtils.clamp((c.scale.x + c.scale.y) * 0.08, 0, 1));
            const scaleAdj = 1 + base * 1.2;
            halo.scale.setScalar(scaleBase * scaleAdj);
            halo.visible = halo.material.opacity > 0.003;
          }
        })();
 
        const typeMap = {
          'cumulus_humilis': 'Cumulus Humilis', 'cumulus_congestus': 'Cumulus Congestus',
          'cumulonimbus': 'Cumulonimbus', 'supercell': 'Supercell', 'derecho': 'Derecho',
          'nimbostratus': 'Nimbostratus', 'altostratus': 'Altostratus', 'cirrus': 'Cirrus'
        };
        const cloudTypes = {};
        cloudSystem.clouds.forEach(c => {
          const t = typeMap[c.userData.type] || c.userData.type;
          cloudTypes[t] = (cloudTypes[t] || 0) + 1;
        });

        let typesList = '';
        Object.entries(cloudTypes).forEach(([type, count]) => {
          const icon = type.includes('Supercell') || type.includes('Derecho') ? '‚ö†Ô∏è ' : '';
          typesList += `<div>${icon}${type}: ${count}</div>`;
        });

        document.getElementById('cloudCount').textContent = cloudSystem.clouds.length;
        document.getElementById('cloudTypesList').innerHTML = typesList;
        document.getElementById('precipitation').textContent = precipClouds.length > 0 ? `Active (${precipClouds.length})` : 'None';
        const activeTornadoCount = tornadoSystem.activeTornadoes.length;
        document.getElementById('tornadoCount').textContent = activeTornadoCount;
        document.getElementById('tornadoWarning').style.display = activeTornadoCount > 0 ? 'block' : 'none';
        document.getElementById('windSpeed').textContent = (windSystem ? (windSystem.getWindSpeed() * state.controls.windSpeed * 100).toFixed(1) : '0.0');
        document.getElementById('tempDisplay').textContent = state.controls.temperature.toFixed(1);
        document.getElementById('humidityDisplay').textContent = state.controls.humidity.toFixed(1);
        
        precipitationSystem.update(precipClouds, windSystem, deltaTime);

        cloudSystem.clouds.forEach(c => {
          // pyro-cloud ember flicker: briefly brighten nearby camera if pyro-cloud flash occurs
          if (c.userData.pyro && Math.random() < 0.0009 * (c.userData.precipitationIntensity || 0.6) * deltaTime * 100) {
            // small ember flash
            camera.position.x += (Math.random()-0.5) * 0.02;
            camera.position.y += (Math.random()-0.5) * 0.02;
          }
          const e = c.userData.rainEmitter;
          if (e && c.userData.precipitating) {
            const dist = e.position.distanceTo(camera.position);
            if (dist < 30) {
              const intensity = c.userData.precipitationIntensity || 0.0;
              const proximity = (30 - dist) / 30;
              const shakeMag = proximity * intensity * 0.7 * e.opacity;
              if (shakeMag > 0.02) {
                camera.position.x += (Math.random() - 0.5) * shakeMag;
                camera.position.y += (Math.random() - 0.5) * (shakeMag * 0.5);
              }
            }
          }
        });

        // update trees each frame
        treeSystem.update(deltaTime);
      } else {
        radarSystem.update(cloudSystem.clouds, [], camera.position);
      }

      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>
